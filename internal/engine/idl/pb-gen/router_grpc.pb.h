// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: router_grpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_router_5fgrpc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_router_5fgrpc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "data_model.pb.h"
#include "errors.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_router_5fgrpc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_router_5fgrpc_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_router_5fgrpc_2eproto;
namespace vearchpb {
class BulkRequest;
struct BulkRequestDefaultTypeInternal;
extern BulkRequestDefaultTypeInternal _BulkRequest_default_instance_;
class BulkResponse;
struct BulkResponseDefaultTypeInternal;
extern BulkResponseDefaultTypeInternal _BulkResponse_default_instance_;
class DelByQueryeResponse;
struct DelByQueryeResponseDefaultTypeInternal;
extern DelByQueryeResponseDefaultTypeInternal _DelByQueryeResponse_default_instance_;
class DeleteRequest;
struct DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class DeleteResponse;
struct DeleteResponseDefaultTypeInternal;
extern DeleteResponseDefaultTypeInternal _DeleteResponse_default_instance_;
class FlushRequest;
struct FlushRequestDefaultTypeInternal;
extern FlushRequestDefaultTypeInternal _FlushRequest_default_instance_;
class FlushResponse;
struct FlushResponseDefaultTypeInternal;
extern FlushResponseDefaultTypeInternal _FlushResponse_default_instance_;
class ForceMergeRequest;
struct ForceMergeRequestDefaultTypeInternal;
extern ForceMergeRequestDefaultTypeInternal _ForceMergeRequest_default_instance_;
class ForceMergeResponse;
struct ForceMergeResponseDefaultTypeInternal;
extern ForceMergeResponseDefaultTypeInternal _ForceMergeResponse_default_instance_;
class GetRequest;
struct GetRequestDefaultTypeInternal;
extern GetRequestDefaultTypeInternal _GetRequest_default_instance_;
class GetResponse;
struct GetResponseDefaultTypeInternal;
extern GetResponseDefaultTypeInternal _GetResponse_default_instance_;
class IndexParameters;
struct IndexParametersDefaultTypeInternal;
extern IndexParametersDefaultTypeInternal _IndexParameters_default_instance_;
class IndexRequest;
struct IndexRequestDefaultTypeInternal;
extern IndexRequestDefaultTypeInternal _IndexRequest_default_instance_;
class IndexResponse;
struct IndexResponseDefaultTypeInternal;
extern IndexResponseDefaultTypeInternal _IndexResponse_default_instance_;
class QueryRequest;
struct QueryRequestDefaultTypeInternal;
extern QueryRequestDefaultTypeInternal _QueryRequest_default_instance_;
class QueryRequest_SortFieldMapEntry_DoNotUse;
struct QueryRequest_SortFieldMapEntry_DoNotUseDefaultTypeInternal;
extern QueryRequest_SortFieldMapEntry_DoNotUseDefaultTypeInternal _QueryRequest_SortFieldMapEntry_DoNotUse_default_instance_;
class RangeFilter;
struct RangeFilterDefaultTypeInternal;
extern RangeFilterDefaultTypeInternal _RangeFilter_default_instance_;
class RequestHead;
struct RequestHeadDefaultTypeInternal;
extern RequestHeadDefaultTypeInternal _RequestHead_default_instance_;
class RequestHead_ParamsEntry_DoNotUse;
struct RequestHead_ParamsEntry_DoNotUseDefaultTypeInternal;
extern RequestHead_ParamsEntry_DoNotUseDefaultTypeInternal _RequestHead_ParamsEntry_DoNotUse_default_instance_;
class ResponseHead;
struct ResponseHeadDefaultTypeInternal;
extern ResponseHeadDefaultTypeInternal _ResponseHead_default_instance_;
class ResponseHead_ParamsEntry_DoNotUse;
struct ResponseHead_ParamsEntry_DoNotUseDefaultTypeInternal;
extern ResponseHead_ParamsEntry_DoNotUseDefaultTypeInternal _ResponseHead_ParamsEntry_DoNotUse_default_instance_;
class ResultItem;
struct ResultItemDefaultTypeInternal;
extern ResultItemDefaultTypeInternal _ResultItem_default_instance_;
class SearchRequest;
struct SearchRequestDefaultTypeInternal;
extern SearchRequestDefaultTypeInternal _SearchRequest_default_instance_;
class SearchRequest_SortFieldMapEntry_DoNotUse;
struct SearchRequest_SortFieldMapEntry_DoNotUseDefaultTypeInternal;
extern SearchRequest_SortFieldMapEntry_DoNotUseDefaultTypeInternal _SearchRequest_SortFieldMapEntry_DoNotUse_default_instance_;
class SearchResponse;
struct SearchResponseDefaultTypeInternal;
extern SearchResponseDefaultTypeInternal _SearchResponse_default_instance_;
class SearchResult;
struct SearchResultDefaultTypeInternal;
extern SearchResultDefaultTypeInternal _SearchResult_default_instance_;
class SearchStatus;
struct SearchStatusDefaultTypeInternal;
extern SearchStatusDefaultTypeInternal _SearchStatus_default_instance_;
class SortField;
struct SortFieldDefaultTypeInternal;
extern SortFieldDefaultTypeInternal _SortField_default_instance_;
class TermFilter;
struct TermFilterDefaultTypeInternal;
extern TermFilterDefaultTypeInternal _TermFilter_default_instance_;
class VectorQuery;
struct VectorQueryDefaultTypeInternal;
extern VectorQueryDefaultTypeInternal _VectorQuery_default_instance_;
}  // namespace vearchpb
PROTOBUF_NAMESPACE_OPEN
template<> ::vearchpb::BulkRequest* Arena::CreateMaybeMessage<::vearchpb::BulkRequest>(Arena*);
template<> ::vearchpb::BulkResponse* Arena::CreateMaybeMessage<::vearchpb::BulkResponse>(Arena*);
template<> ::vearchpb::DelByQueryeResponse* Arena::CreateMaybeMessage<::vearchpb::DelByQueryeResponse>(Arena*);
template<> ::vearchpb::DeleteRequest* Arena::CreateMaybeMessage<::vearchpb::DeleteRequest>(Arena*);
template<> ::vearchpb::DeleteResponse* Arena::CreateMaybeMessage<::vearchpb::DeleteResponse>(Arena*);
template<> ::vearchpb::FlushRequest* Arena::CreateMaybeMessage<::vearchpb::FlushRequest>(Arena*);
template<> ::vearchpb::FlushResponse* Arena::CreateMaybeMessage<::vearchpb::FlushResponse>(Arena*);
template<> ::vearchpb::ForceMergeRequest* Arena::CreateMaybeMessage<::vearchpb::ForceMergeRequest>(Arena*);
template<> ::vearchpb::ForceMergeResponse* Arena::CreateMaybeMessage<::vearchpb::ForceMergeResponse>(Arena*);
template<> ::vearchpb::GetRequest* Arena::CreateMaybeMessage<::vearchpb::GetRequest>(Arena*);
template<> ::vearchpb::GetResponse* Arena::CreateMaybeMessage<::vearchpb::GetResponse>(Arena*);
template<> ::vearchpb::IndexParameters* Arena::CreateMaybeMessage<::vearchpb::IndexParameters>(Arena*);
template<> ::vearchpb::IndexRequest* Arena::CreateMaybeMessage<::vearchpb::IndexRequest>(Arena*);
template<> ::vearchpb::IndexResponse* Arena::CreateMaybeMessage<::vearchpb::IndexResponse>(Arena*);
template<> ::vearchpb::QueryRequest* Arena::CreateMaybeMessage<::vearchpb::QueryRequest>(Arena*);
template<> ::vearchpb::QueryRequest_SortFieldMapEntry_DoNotUse* Arena::CreateMaybeMessage<::vearchpb::QueryRequest_SortFieldMapEntry_DoNotUse>(Arena*);
template<> ::vearchpb::RangeFilter* Arena::CreateMaybeMessage<::vearchpb::RangeFilter>(Arena*);
template<> ::vearchpb::RequestHead* Arena::CreateMaybeMessage<::vearchpb::RequestHead>(Arena*);
template<> ::vearchpb::RequestHead_ParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::vearchpb::RequestHead_ParamsEntry_DoNotUse>(Arena*);
template<> ::vearchpb::ResponseHead* Arena::CreateMaybeMessage<::vearchpb::ResponseHead>(Arena*);
template<> ::vearchpb::ResponseHead_ParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::vearchpb::ResponseHead_ParamsEntry_DoNotUse>(Arena*);
template<> ::vearchpb::ResultItem* Arena::CreateMaybeMessage<::vearchpb::ResultItem>(Arena*);
template<> ::vearchpb::SearchRequest* Arena::CreateMaybeMessage<::vearchpb::SearchRequest>(Arena*);
template<> ::vearchpb::SearchRequest_SortFieldMapEntry_DoNotUse* Arena::CreateMaybeMessage<::vearchpb::SearchRequest_SortFieldMapEntry_DoNotUse>(Arena*);
template<> ::vearchpb::SearchResponse* Arena::CreateMaybeMessage<::vearchpb::SearchResponse>(Arena*);
template<> ::vearchpb::SearchResult* Arena::CreateMaybeMessage<::vearchpb::SearchResult>(Arena*);
template<> ::vearchpb::SearchStatus* Arena::CreateMaybeMessage<::vearchpb::SearchStatus>(Arena*);
template<> ::vearchpb::SortField* Arena::CreateMaybeMessage<::vearchpb::SortField>(Arena*);
template<> ::vearchpb::TermFilter* Arena::CreateMaybeMessage<::vearchpb::TermFilter>(Arena*);
template<> ::vearchpb::VectorQuery* Arena::CreateMaybeMessage<::vearchpb::VectorQuery>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vearchpb {

enum IndexParameters_DistanceMetricType : int {
  IndexParameters_DistanceMetricType_InnerProduct = 0,
  IndexParameters_DistanceMetricType_L2 = 1,
  IndexParameters_DistanceMetricType_IndexParameters_DistanceMetricType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IndexParameters_DistanceMetricType_IndexParameters_DistanceMetricType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IndexParameters_DistanceMetricType_IsValid(int value);
constexpr IndexParameters_DistanceMetricType IndexParameters_DistanceMetricType_DistanceMetricType_MIN = IndexParameters_DistanceMetricType_InnerProduct;
constexpr IndexParameters_DistanceMetricType IndexParameters_DistanceMetricType_DistanceMetricType_MAX = IndexParameters_DistanceMetricType_L2;
constexpr int IndexParameters_DistanceMetricType_DistanceMetricType_ARRAYSIZE = IndexParameters_DistanceMetricType_DistanceMetricType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IndexParameters_DistanceMetricType_descriptor();
template<typename T>
inline const std::string& IndexParameters_DistanceMetricType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IndexParameters_DistanceMetricType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IndexParameters_DistanceMetricType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IndexParameters_DistanceMetricType_descriptor(), enum_t_value);
}
inline bool IndexParameters_DistanceMetricType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IndexParameters_DistanceMetricType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IndexParameters_DistanceMetricType>(
    IndexParameters_DistanceMetricType_descriptor(), name, value);
}
// ===================================================================

class RequestHead_ParamsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RequestHead_ParamsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RequestHead_ParamsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  RequestHead_ParamsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR RequestHead_ParamsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RequestHead_ParamsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RequestHead_ParamsEntry_DoNotUse& other);
  static const RequestHead_ParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RequestHead_ParamsEntry_DoNotUse*>(&_RequestHead_ParamsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vearchpb.RequestHead.ParamsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vearchpb.RequestHead.ParamsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};

// -------------------------------------------------------------------

class RequestHead final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.RequestHead) */ {
 public:
  inline RequestHead() : RequestHead(nullptr) {}
  ~RequestHead() override;
  explicit PROTOBUF_CONSTEXPR RequestHead(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestHead(const RequestHead& from);
  RequestHead(RequestHead&& from) noexcept
    : RequestHead() {
    *this = ::std::move(from);
  }

  inline RequestHead& operator=(const RequestHead& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestHead& operator=(RequestHead&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestHead& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestHead* internal_default_instance() {
    return reinterpret_cast<const RequestHead*>(
               &_RequestHead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RequestHead& a, RequestHead& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestHead* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestHead* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestHead* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestHead>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestHead& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestHead& from) {
    RequestHead::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestHead* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.RequestHead";
  }
  protected:
  explicit RequestHead(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 7,
    kUserNameFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kDbNameFieldNumber = 4,
    kSpaceNameFieldNumber = 5,
    kClientTypeFieldNumber = 6,
    kTimeOutMsFieldNumber = 1,
  };
  // map<string, string> params = 7;
  int params_size() const;
  private:
  int _internal_params_size() const;
  public:
  void clear_params();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_params();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_params();

  // string user_name = 2;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string db_name = 4;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string space_name = 5;
  void clear_space_name();
  const std::string& space_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_space_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_space_name();
  PROTOBUF_NODISCARD std::string* release_space_name();
  void set_allocated_space_name(std::string* space_name);
  private:
  const std::string& _internal_space_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_space_name(const std::string& value);
  std::string* _internal_mutable_space_name();
  public:

  // string client_type = 6;
  void clear_client_type();
  const std::string& client_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_type();
  PROTOBUF_NODISCARD std::string* release_client_type();
  void set_allocated_client_type(std::string* client_type);
  private:
  const std::string& _internal_client_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_type(const std::string& value);
  std::string* _internal_mutable_client_type();
  public:

  // int64 time_out_ms = 1;
  void clear_time_out_ms();
  int64_t time_out_ms() const;
  void set_time_out_ms(int64_t value);
  private:
  int64_t _internal_time_out_ms() const;
  void _internal_set_time_out_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vearchpb.RequestHead)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        RequestHead_ParamsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> params_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr space_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_type_;
    int64_t time_out_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class ResponseHead_ParamsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ResponseHead_ParamsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ResponseHead_ParamsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ResponseHead_ParamsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ResponseHead_ParamsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ResponseHead_ParamsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ResponseHead_ParamsEntry_DoNotUse& other);
  static const ResponseHead_ParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ResponseHead_ParamsEntry_DoNotUse*>(&_ResponseHead_ParamsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vearchpb.ResponseHead.ParamsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vearchpb.ResponseHead.ParamsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};

// -------------------------------------------------------------------

class ResponseHead final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.ResponseHead) */ {
 public:
  inline ResponseHead() : ResponseHead(nullptr) {}
  ~ResponseHead() override;
  explicit PROTOBUF_CONSTEXPR ResponseHead(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseHead(const ResponseHead& from);
  ResponseHead(ResponseHead&& from) noexcept
    : ResponseHead() {
    *this = ::std::move(from);
  }

  inline ResponseHead& operator=(const ResponseHead& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseHead& operator=(ResponseHead&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseHead& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseHead* internal_default_instance() {
    return reinterpret_cast<const ResponseHead*>(
               &_ResponseHead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ResponseHead& a, ResponseHead& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseHead* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseHead* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseHead* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseHead>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseHead& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseHead& from) {
    ResponseHead::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseHead* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.ResponseHead";
  }
  protected:
  explicit ResponseHead(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 3,
    kRequestIdFieldNumber = 1,
    kErrFieldNumber = 2,
  };
  // map<string, string> params = 3;
  int params_size() const;
  private:
  int _internal_params_size() const;
  public:
  void clear_params();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_params();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_params();

  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // .vearchpb.Error err = 2;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::vearchpb::Error& err() const;
  PROTOBUF_NODISCARD ::vearchpb::Error* release_err();
  ::vearchpb::Error* mutable_err();
  void set_allocated_err(::vearchpb::Error* err);
  private:
  const ::vearchpb::Error& _internal_err() const;
  ::vearchpb::Error* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::vearchpb::Error* err);
  ::vearchpb::Error* unsafe_arena_release_err();

  // @@protoc_insertion_point(class_scope:vearchpb.ResponseHead)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ResponseHead_ParamsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> params_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::vearchpb::Error* err_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class GetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.GetRequest) */ {
 public:
  inline GetRequest() : GetRequest(nullptr) {}
  ~GetRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRequest(const GetRequest& from);
  GetRequest(GetRequest&& from) noexcept
    : GetRequest() {
    *this = ::std::move(from);
  }

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRequest& operator=(GetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRequest* internal_default_instance() {
    return reinterpret_cast<const GetRequest*>(
               &_GetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetRequest& a, GetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRequest& from) {
    GetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.GetRequest";
  }
  protected:
  explicit GetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrimaryKeysFieldNumber = 2,
    kHeadFieldNumber = 1,
  };
  // repeated string primary_keys = 2;
  int primary_keys_size() const;
  private:
  int _internal_primary_keys_size() const;
  public:
  void clear_primary_keys();
  const std::string& primary_keys(int index) const;
  std::string* mutable_primary_keys(int index);
  void set_primary_keys(int index, const std::string& value);
  void set_primary_keys(int index, std::string&& value);
  void set_primary_keys(int index, const char* value);
  void set_primary_keys(int index, const char* value, size_t size);
  std::string* add_primary_keys();
  void add_primary_keys(const std::string& value);
  void add_primary_keys(std::string&& value);
  void add_primary_keys(const char* value);
  void add_primary_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& primary_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_primary_keys();
  private:
  const std::string& _internal_primary_keys(int index) const;
  std::string* _internal_add_primary_keys();
  public:

  // .vearchpb.RequestHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::vearchpb::RequestHead& head() const;
  PROTOBUF_NODISCARD ::vearchpb::RequestHead* release_head();
  ::vearchpb::RequestHead* mutable_head();
  void set_allocated_head(::vearchpb::RequestHead* head);
  private:
  const ::vearchpb::RequestHead& _internal_head() const;
  ::vearchpb::RequestHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::vearchpb::RequestHead* head);
  ::vearchpb::RequestHead* unsafe_arena_release_head();

  // @@protoc_insertion_point(class_scope:vearchpb.GetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> primary_keys_;
    ::vearchpb::RequestHead* head_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.DeleteRequest) */ {
 public:
  inline DeleteRequest() : DeleteRequest(nullptr) {}
  ~DeleteRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRequest(const DeleteRequest& from);
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRequest& from) {
    DeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.DeleteRequest";
  }
  protected:
  explicit DeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrimaryKeysFieldNumber = 2,
    kHeadFieldNumber = 1,
  };
  // repeated string primary_keys = 2;
  int primary_keys_size() const;
  private:
  int _internal_primary_keys_size() const;
  public:
  void clear_primary_keys();
  const std::string& primary_keys(int index) const;
  std::string* mutable_primary_keys(int index);
  void set_primary_keys(int index, const std::string& value);
  void set_primary_keys(int index, std::string&& value);
  void set_primary_keys(int index, const char* value);
  void set_primary_keys(int index, const char* value, size_t size);
  std::string* add_primary_keys();
  void add_primary_keys(const std::string& value);
  void add_primary_keys(std::string&& value);
  void add_primary_keys(const char* value);
  void add_primary_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& primary_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_primary_keys();
  private:
  const std::string& _internal_primary_keys(int index) const;
  std::string* _internal_add_primary_keys();
  public:

  // .vearchpb.RequestHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::vearchpb::RequestHead& head() const;
  PROTOBUF_NODISCARD ::vearchpb::RequestHead* release_head();
  ::vearchpb::RequestHead* mutable_head();
  void set_allocated_head(::vearchpb::RequestHead* head);
  private:
  const ::vearchpb::RequestHead& _internal_head() const;
  ::vearchpb::RequestHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::vearchpb::RequestHead* head);
  ::vearchpb::RequestHead* unsafe_arena_release_head();

  // @@protoc_insertion_point(class_scope:vearchpb.DeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> primary_keys_;
    ::vearchpb::RequestHead* head_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class BulkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.BulkRequest) */ {
 public:
  inline BulkRequest() : BulkRequest(nullptr) {}
  ~BulkRequest() override;
  explicit PROTOBUF_CONSTEXPR BulkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BulkRequest(const BulkRequest& from);
  BulkRequest(BulkRequest&& from) noexcept
    : BulkRequest() {
    *this = ::std::move(from);
  }

  inline BulkRequest& operator=(const BulkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BulkRequest& operator=(BulkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BulkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BulkRequest* internal_default_instance() {
    return reinterpret_cast<const BulkRequest*>(
               &_BulkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BulkRequest& a, BulkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BulkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BulkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BulkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BulkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BulkRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BulkRequest& from) {
    BulkRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulkRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.BulkRequest";
  }
  protected:
  explicit BulkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocsFieldNumber = 2,
    kPartitionsFieldNumber = 3,
    kHeadFieldNumber = 1,
  };
  // repeated .vearchpb.Document docs = 2;
  int docs_size() const;
  private:
  int _internal_docs_size() const;
  public:
  void clear_docs();
  ::vearchpb::Document* mutable_docs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Document >*
      mutable_docs();
  private:
  const ::vearchpb::Document& _internal_docs(int index) const;
  ::vearchpb::Document* _internal_add_docs();
  public:
  const ::vearchpb::Document& docs(int index) const;
  ::vearchpb::Document* add_docs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Document >&
      docs() const;

  // repeated uint32 partitions = 3;
  int partitions_size() const;
  private:
  int _internal_partitions_size() const;
  public:
  void clear_partitions();
  private:
  uint32_t _internal_partitions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_partitions() const;
  void _internal_add_partitions(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_partitions();
  public:
  uint32_t partitions(int index) const;
  void set_partitions(int index, uint32_t value);
  void add_partitions(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      partitions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_partitions();

  // .vearchpb.RequestHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::vearchpb::RequestHead& head() const;
  PROTOBUF_NODISCARD ::vearchpb::RequestHead* release_head();
  ::vearchpb::RequestHead* mutable_head();
  void set_allocated_head(::vearchpb::RequestHead* head);
  private:
  const ::vearchpb::RequestHead& _internal_head() const;
  ::vearchpb::RequestHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::vearchpb::RequestHead* head);
  ::vearchpb::RequestHead* unsafe_arena_release_head();

  // @@protoc_insertion_point(class_scope:vearchpb.BulkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Document > docs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > partitions_;
    mutable std::atomic<int> _partitions_cached_byte_size_;
    ::vearchpb::RequestHead* head_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class ForceMergeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.ForceMergeRequest) */ {
 public:
  inline ForceMergeRequest() : ForceMergeRequest(nullptr) {}
  ~ForceMergeRequest() override;
  explicit PROTOBUF_CONSTEXPR ForceMergeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForceMergeRequest(const ForceMergeRequest& from);
  ForceMergeRequest(ForceMergeRequest&& from) noexcept
    : ForceMergeRequest() {
    *this = ::std::move(from);
  }

  inline ForceMergeRequest& operator=(const ForceMergeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForceMergeRequest& operator=(ForceMergeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForceMergeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForceMergeRequest* internal_default_instance() {
    return reinterpret_cast<const ForceMergeRequest*>(
               &_ForceMergeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ForceMergeRequest& a, ForceMergeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ForceMergeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForceMergeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForceMergeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForceMergeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForceMergeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ForceMergeRequest& from) {
    ForceMergeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForceMergeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.ForceMergeRequest";
  }
  protected:
  explicit ForceMergeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadFieldNumber = 1,
  };
  // .vearchpb.RequestHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::vearchpb::RequestHead& head() const;
  PROTOBUF_NODISCARD ::vearchpb::RequestHead* release_head();
  ::vearchpb::RequestHead* mutable_head();
  void set_allocated_head(::vearchpb::RequestHead* head);
  private:
  const ::vearchpb::RequestHead& _internal_head() const;
  ::vearchpb::RequestHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::vearchpb::RequestHead* head);
  ::vearchpb::RequestHead* unsafe_arena_release_head();

  // @@protoc_insertion_point(class_scope:vearchpb.ForceMergeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::vearchpb::RequestHead* head_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class FlushRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.FlushRequest) */ {
 public:
  inline FlushRequest() : FlushRequest(nullptr) {}
  ~FlushRequest() override;
  explicit PROTOBUF_CONSTEXPR FlushRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlushRequest(const FlushRequest& from);
  FlushRequest(FlushRequest&& from) noexcept
    : FlushRequest() {
    *this = ::std::move(from);
  }

  inline FlushRequest& operator=(const FlushRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushRequest& operator=(FlushRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlushRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlushRequest* internal_default_instance() {
    return reinterpret_cast<const FlushRequest*>(
               &_FlushRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FlushRequest& a, FlushRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FlushRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlushRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlushRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlushRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlushRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlushRequest& from) {
    FlushRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlushRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.FlushRequest";
  }
  protected:
  explicit FlushRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadFieldNumber = 1,
  };
  // .vearchpb.RequestHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::vearchpb::RequestHead& head() const;
  PROTOBUF_NODISCARD ::vearchpb::RequestHead* release_head();
  ::vearchpb::RequestHead* mutable_head();
  void set_allocated_head(::vearchpb::RequestHead* head);
  private:
  const ::vearchpb::RequestHead& _internal_head() const;
  ::vearchpb::RequestHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::vearchpb::RequestHead* head);
  ::vearchpb::RequestHead* unsafe_arena_release_head();

  // @@protoc_insertion_point(class_scope:vearchpb.FlushRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::vearchpb::RequestHead* head_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class IndexRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.IndexRequest) */ {
 public:
  inline IndexRequest() : IndexRequest(nullptr) {}
  ~IndexRequest() override;
  explicit PROTOBUF_CONSTEXPR IndexRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndexRequest(const IndexRequest& from);
  IndexRequest(IndexRequest&& from) noexcept
    : IndexRequest() {
    *this = ::std::move(from);
  }

  inline IndexRequest& operator=(const IndexRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexRequest& operator=(IndexRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndexRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndexRequest* internal_default_instance() {
    return reinterpret_cast<const IndexRequest*>(
               &_IndexRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(IndexRequest& a, IndexRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IndexRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IndexRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndexRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IndexRequest& from) {
    IndexRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.IndexRequest";
  }
  protected:
  explicit IndexRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadFieldNumber = 1,
    kDropBeforeRebuildFieldNumber = 2,
    kLimitCpuFieldNumber = 3,
    kDescribeFieldNumber = 4,
    kPartitionIdFieldNumber = 5,
  };
  // .vearchpb.RequestHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::vearchpb::RequestHead& head() const;
  PROTOBUF_NODISCARD ::vearchpb::RequestHead* release_head();
  ::vearchpb::RequestHead* mutable_head();
  void set_allocated_head(::vearchpb::RequestHead* head);
  private:
  const ::vearchpb::RequestHead& _internal_head() const;
  ::vearchpb::RequestHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::vearchpb::RequestHead* head);
  ::vearchpb::RequestHead* unsafe_arena_release_head();

  // int64 drop_before_rebuild = 2;
  void clear_drop_before_rebuild();
  int64_t drop_before_rebuild() const;
  void set_drop_before_rebuild(int64_t value);
  private:
  int64_t _internal_drop_before_rebuild() const;
  void _internal_set_drop_before_rebuild(int64_t value);
  public:

  // int64 limit_cpu = 3;
  void clear_limit_cpu();
  int64_t limit_cpu() const;
  void set_limit_cpu(int64_t value);
  private:
  int64_t _internal_limit_cpu() const;
  void _internal_set_limit_cpu(int64_t value);
  public:

  // int64 describe = 4;
  void clear_describe();
  int64_t describe() const;
  void set_describe(int64_t value);
  private:
  int64_t _internal_describe() const;
  void _internal_set_describe(int64_t value);
  public:

  // uint32 partition_id = 5;
  void clear_partition_id();
  uint32_t partition_id() const;
  void set_partition_id(uint32_t value);
  private:
  uint32_t _internal_partition_id() const;
  void _internal_set_partition_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vearchpb.IndexRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::vearchpb::RequestHead* head_;
    int64_t drop_before_rebuild_;
    int64_t limit_cpu_;
    int64_t describe_;
    uint32_t partition_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class GetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.GetResponse) */ {
 public:
  inline GetResponse() : GetResponse(nullptr) {}
  ~GetResponse() override;
  explicit PROTOBUF_CONSTEXPR GetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponse(const GetResponse& from);
  GetResponse(GetResponse&& from) noexcept
    : GetResponse() {
    *this = ::std::move(from);
  }

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponse& operator=(GetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponse*>(
               &_GetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetResponse& a, GetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponse& from) {
    GetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.GetResponse";
  }
  protected:
  explicit GetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kHeadFieldNumber = 1,
  };
  // repeated .vearchpb.Item items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::vearchpb::Item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Item >*
      mutable_items();
  private:
  const ::vearchpb::Item& _internal_items(int index) const;
  ::vearchpb::Item* _internal_add_items();
  public:
  const ::vearchpb::Item& items(int index) const;
  ::vearchpb::Item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Item >&
      items() const;

  // .vearchpb.ResponseHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::vearchpb::ResponseHead& head() const;
  PROTOBUF_NODISCARD ::vearchpb::ResponseHead* release_head();
  ::vearchpb::ResponseHead* mutable_head();
  void set_allocated_head(::vearchpb::ResponseHead* head);
  private:
  const ::vearchpb::ResponseHead& _internal_head() const;
  ::vearchpb::ResponseHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::vearchpb::ResponseHead* head);
  ::vearchpb::ResponseHead* unsafe_arena_release_head();

  // @@protoc_insertion_point(class_scope:vearchpb.GetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Item > items_;
    ::vearchpb::ResponseHead* head_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class DeleteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.DeleteResponse) */ {
 public:
  inline DeleteResponse() : DeleteResponse(nullptr) {}
  ~DeleteResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteResponse(const DeleteResponse& from);
  DeleteResponse(DeleteResponse&& from) noexcept
    : DeleteResponse() {
    *this = ::std::move(from);
  }

  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteResponse& operator=(DeleteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteResponse*>(
               &_DeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DeleteResponse& a, DeleteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteResponse& from) {
    DeleteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.DeleteResponse";
  }
  protected:
  explicit DeleteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kHeadFieldNumber = 1,
  };
  // repeated .vearchpb.Item items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::vearchpb::Item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Item >*
      mutable_items();
  private:
  const ::vearchpb::Item& _internal_items(int index) const;
  ::vearchpb::Item* _internal_add_items();
  public:
  const ::vearchpb::Item& items(int index) const;
  ::vearchpb::Item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Item >&
      items() const;

  // .vearchpb.ResponseHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::vearchpb::ResponseHead& head() const;
  PROTOBUF_NODISCARD ::vearchpb::ResponseHead* release_head();
  ::vearchpb::ResponseHead* mutable_head();
  void set_allocated_head(::vearchpb::ResponseHead* head);
  private:
  const ::vearchpb::ResponseHead& _internal_head() const;
  ::vearchpb::ResponseHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::vearchpb::ResponseHead* head);
  ::vearchpb::ResponseHead* unsafe_arena_release_head();

  // @@protoc_insertion_point(class_scope:vearchpb.DeleteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Item > items_;
    ::vearchpb::ResponseHead* head_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class BulkResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.BulkResponse) */ {
 public:
  inline BulkResponse() : BulkResponse(nullptr) {}
  ~BulkResponse() override;
  explicit PROTOBUF_CONSTEXPR BulkResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BulkResponse(const BulkResponse& from);
  BulkResponse(BulkResponse&& from) noexcept
    : BulkResponse() {
    *this = ::std::move(from);
  }

  inline BulkResponse& operator=(const BulkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BulkResponse& operator=(BulkResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BulkResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BulkResponse* internal_default_instance() {
    return reinterpret_cast<const BulkResponse*>(
               &_BulkResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(BulkResponse& a, BulkResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BulkResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BulkResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BulkResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BulkResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BulkResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BulkResponse& from) {
    BulkResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulkResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.BulkResponse";
  }
  protected:
  explicit BulkResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kHeadFieldNumber = 1,
  };
  // repeated .vearchpb.Item items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::vearchpb::Item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Item >*
      mutable_items();
  private:
  const ::vearchpb::Item& _internal_items(int index) const;
  ::vearchpb::Item* _internal_add_items();
  public:
  const ::vearchpb::Item& items(int index) const;
  ::vearchpb::Item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Item >&
      items() const;

  // .vearchpb.ResponseHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::vearchpb::ResponseHead& head() const;
  PROTOBUF_NODISCARD ::vearchpb::ResponseHead* release_head();
  ::vearchpb::ResponseHead* mutable_head();
  void set_allocated_head(::vearchpb::ResponseHead* head);
  private:
  const ::vearchpb::ResponseHead& _internal_head() const;
  ::vearchpb::ResponseHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::vearchpb::ResponseHead* head);
  ::vearchpb::ResponseHead* unsafe_arena_release_head();

  // @@protoc_insertion_point(class_scope:vearchpb.BulkResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Item > items_;
    ::vearchpb::ResponseHead* head_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class ForceMergeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.ForceMergeResponse) */ {
 public:
  inline ForceMergeResponse() : ForceMergeResponse(nullptr) {}
  ~ForceMergeResponse() override;
  explicit PROTOBUF_CONSTEXPR ForceMergeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForceMergeResponse(const ForceMergeResponse& from);
  ForceMergeResponse(ForceMergeResponse&& from) noexcept
    : ForceMergeResponse() {
    *this = ::std::move(from);
  }

  inline ForceMergeResponse& operator=(const ForceMergeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForceMergeResponse& operator=(ForceMergeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForceMergeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForceMergeResponse* internal_default_instance() {
    return reinterpret_cast<const ForceMergeResponse*>(
               &_ForceMergeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ForceMergeResponse& a, ForceMergeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ForceMergeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForceMergeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForceMergeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForceMergeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForceMergeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ForceMergeResponse& from) {
    ForceMergeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForceMergeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.ForceMergeResponse";
  }
  protected:
  explicit ForceMergeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadFieldNumber = 1,
    kShardsFieldNumber = 2,
  };
  // .vearchpb.ResponseHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::vearchpb::ResponseHead& head() const;
  PROTOBUF_NODISCARD ::vearchpb::ResponseHead* release_head();
  ::vearchpb::ResponseHead* mutable_head();
  void set_allocated_head(::vearchpb::ResponseHead* head);
  private:
  const ::vearchpb::ResponseHead& _internal_head() const;
  ::vearchpb::ResponseHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::vearchpb::ResponseHead* head);
  ::vearchpb::ResponseHead* unsafe_arena_release_head();

  // .vearchpb.SearchStatus shards = 2;
  bool has_shards() const;
  private:
  bool _internal_has_shards() const;
  public:
  void clear_shards();
  const ::vearchpb::SearchStatus& shards() const;
  PROTOBUF_NODISCARD ::vearchpb::SearchStatus* release_shards();
  ::vearchpb::SearchStatus* mutable_shards();
  void set_allocated_shards(::vearchpb::SearchStatus* shards);
  private:
  const ::vearchpb::SearchStatus& _internal_shards() const;
  ::vearchpb::SearchStatus* _internal_mutable_shards();
  public:
  void unsafe_arena_set_allocated_shards(
      ::vearchpb::SearchStatus* shards);
  ::vearchpb::SearchStatus* unsafe_arena_release_shards();

  // @@protoc_insertion_point(class_scope:vearchpb.ForceMergeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::vearchpb::ResponseHead* head_;
    ::vearchpb::SearchStatus* shards_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class DelByQueryeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.DelByQueryeResponse) */ {
 public:
  inline DelByQueryeResponse() : DelByQueryeResponse(nullptr) {}
  ~DelByQueryeResponse() override;
  explicit PROTOBUF_CONSTEXPR DelByQueryeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelByQueryeResponse(const DelByQueryeResponse& from);
  DelByQueryeResponse(DelByQueryeResponse&& from) noexcept
    : DelByQueryeResponse() {
    *this = ::std::move(from);
  }

  inline DelByQueryeResponse& operator=(const DelByQueryeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelByQueryeResponse& operator=(DelByQueryeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelByQueryeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelByQueryeResponse* internal_default_instance() {
    return reinterpret_cast<const DelByQueryeResponse*>(
               &_DelByQueryeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DelByQueryeResponse& a, DelByQueryeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DelByQueryeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelByQueryeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelByQueryeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelByQueryeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelByQueryeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DelByQueryeResponse& from) {
    DelByQueryeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelByQueryeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.DelByQueryeResponse";
  }
  protected:
  explicit DelByQueryeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsStrFieldNumber = 3,
    kHeadFieldNumber = 1,
    kDelNumFieldNumber = 2,
  };
  // repeated string ids_str = 3;
  int ids_str_size() const;
  private:
  int _internal_ids_str_size() const;
  public:
  void clear_ids_str();
  const std::string& ids_str(int index) const;
  std::string* mutable_ids_str(int index);
  void set_ids_str(int index, const std::string& value);
  void set_ids_str(int index, std::string&& value);
  void set_ids_str(int index, const char* value);
  void set_ids_str(int index, const char* value, size_t size);
  std::string* add_ids_str();
  void add_ids_str(const std::string& value);
  void add_ids_str(std::string&& value);
  void add_ids_str(const char* value);
  void add_ids_str(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ids_str() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ids_str();
  private:
  const std::string& _internal_ids_str(int index) const;
  std::string* _internal_add_ids_str();
  public:

  // .vearchpb.ResponseHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::vearchpb::ResponseHead& head() const;
  PROTOBUF_NODISCARD ::vearchpb::ResponseHead* release_head();
  ::vearchpb::ResponseHead* mutable_head();
  void set_allocated_head(::vearchpb::ResponseHead* head);
  private:
  const ::vearchpb::ResponseHead& _internal_head() const;
  ::vearchpb::ResponseHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::vearchpb::ResponseHead* head);
  ::vearchpb::ResponseHead* unsafe_arena_release_head();

  // int32 DelNum = 2;
  void clear_delnum();
  int32_t delnum() const;
  void set_delnum(int32_t value);
  private:
  int32_t _internal_delnum() const;
  void _internal_set_delnum(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vearchpb.DelByQueryeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ids_str_;
    ::vearchpb::ResponseHead* head_;
    int32_t delnum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class FlushResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.FlushResponse) */ {
 public:
  inline FlushResponse() : FlushResponse(nullptr) {}
  ~FlushResponse() override;
  explicit PROTOBUF_CONSTEXPR FlushResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlushResponse(const FlushResponse& from);
  FlushResponse(FlushResponse&& from) noexcept
    : FlushResponse() {
    *this = ::std::move(from);
  }

  inline FlushResponse& operator=(const FlushResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushResponse& operator=(FlushResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlushResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlushResponse* internal_default_instance() {
    return reinterpret_cast<const FlushResponse*>(
               &_FlushResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(FlushResponse& a, FlushResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FlushResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlushResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlushResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlushResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlushResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlushResponse& from) {
    FlushResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlushResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.FlushResponse";
  }
  protected:
  explicit FlushResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadFieldNumber = 1,
    kShardsFieldNumber = 2,
  };
  // .vearchpb.ResponseHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::vearchpb::ResponseHead& head() const;
  PROTOBUF_NODISCARD ::vearchpb::ResponseHead* release_head();
  ::vearchpb::ResponseHead* mutable_head();
  void set_allocated_head(::vearchpb::ResponseHead* head);
  private:
  const ::vearchpb::ResponseHead& _internal_head() const;
  ::vearchpb::ResponseHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::vearchpb::ResponseHead* head);
  ::vearchpb::ResponseHead* unsafe_arena_release_head();

  // .vearchpb.SearchStatus shards = 2;
  bool has_shards() const;
  private:
  bool _internal_has_shards() const;
  public:
  void clear_shards();
  const ::vearchpb::SearchStatus& shards() const;
  PROTOBUF_NODISCARD ::vearchpb::SearchStatus* release_shards();
  ::vearchpb::SearchStatus* mutable_shards();
  void set_allocated_shards(::vearchpb::SearchStatus* shards);
  private:
  const ::vearchpb::SearchStatus& _internal_shards() const;
  ::vearchpb::SearchStatus* _internal_mutable_shards();
  public:
  void unsafe_arena_set_allocated_shards(
      ::vearchpb::SearchStatus* shards);
  ::vearchpb::SearchStatus* unsafe_arena_release_shards();

  // @@protoc_insertion_point(class_scope:vearchpb.FlushResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::vearchpb::ResponseHead* head_;
    ::vearchpb::SearchStatus* shards_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class IndexResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.IndexResponse) */ {
 public:
  inline IndexResponse() : IndexResponse(nullptr) {}
  ~IndexResponse() override;
  explicit PROTOBUF_CONSTEXPR IndexResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndexResponse(const IndexResponse& from);
  IndexResponse(IndexResponse&& from) noexcept
    : IndexResponse() {
    *this = ::std::move(from);
  }

  inline IndexResponse& operator=(const IndexResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexResponse& operator=(IndexResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndexResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndexResponse* internal_default_instance() {
    return reinterpret_cast<const IndexResponse*>(
               &_IndexResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(IndexResponse& a, IndexResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IndexResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IndexResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndexResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IndexResponse& from) {
    IndexResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.IndexResponse";
  }
  protected:
  explicit IndexResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadFieldNumber = 1,
    kShardsFieldNumber = 2,
  };
  // .vearchpb.ResponseHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::vearchpb::ResponseHead& head() const;
  PROTOBUF_NODISCARD ::vearchpb::ResponseHead* release_head();
  ::vearchpb::ResponseHead* mutable_head();
  void set_allocated_head(::vearchpb::ResponseHead* head);
  private:
  const ::vearchpb::ResponseHead& _internal_head() const;
  ::vearchpb::ResponseHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::vearchpb::ResponseHead* head);
  ::vearchpb::ResponseHead* unsafe_arena_release_head();

  // .vearchpb.SearchStatus shards = 2;
  bool has_shards() const;
  private:
  bool _internal_has_shards() const;
  public:
  void clear_shards();
  const ::vearchpb::SearchStatus& shards() const;
  PROTOBUF_NODISCARD ::vearchpb::SearchStatus* release_shards();
  ::vearchpb::SearchStatus* mutable_shards();
  void set_allocated_shards(::vearchpb::SearchStatus* shards);
  private:
  const ::vearchpb::SearchStatus& _internal_shards() const;
  ::vearchpb::SearchStatus* _internal_mutable_shards();
  public:
  void unsafe_arena_set_allocated_shards(
      ::vearchpb::SearchStatus* shards);
  ::vearchpb::SearchStatus* unsafe_arena_release_shards();

  // @@protoc_insertion_point(class_scope:vearchpb.IndexResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::vearchpb::ResponseHead* head_;
    ::vearchpb::SearchStatus* shards_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class TermFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.TermFilter) */ {
 public:
  inline TermFilter() : TermFilter(nullptr) {}
  ~TermFilter() override;
  explicit PROTOBUF_CONSTEXPR TermFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TermFilter(const TermFilter& from);
  TermFilter(TermFilter&& from) noexcept
    : TermFilter() {
    *this = ::std::move(from);
  }

  inline TermFilter& operator=(const TermFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline TermFilter& operator=(TermFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TermFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const TermFilter* internal_default_instance() {
    return reinterpret_cast<const TermFilter*>(
               &_TermFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TermFilter& a, TermFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(TermFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TermFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TermFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TermFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TermFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TermFilter& from) {
    TermFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TermFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.TermFilter";
  }
  protected:
  explicit TermFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
    kValueFieldNumber = 2,
    kIsUnionFieldNumber = 3,
  };
  // string field = 1;
  void clear_field();
  const std::string& field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field();
  PROTOBUF_NODISCARD std::string* release_field();
  void set_allocated_field(std::string* field);
  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(const std::string& value);
  std::string* _internal_mutable_field();
  public:

  // bytes value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // int32 is_union = 3;
  void clear_is_union();
  int32_t is_union() const;
  void set_is_union(int32_t value);
  private:
  int32_t _internal_is_union() const;
  void _internal_set_is_union(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vearchpb.TermFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    int32_t is_union_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class RangeFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.RangeFilter) */ {
 public:
  inline RangeFilter() : RangeFilter(nullptr) {}
  ~RangeFilter() override;
  explicit PROTOBUF_CONSTEXPR RangeFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RangeFilter(const RangeFilter& from);
  RangeFilter(RangeFilter&& from) noexcept
    : RangeFilter() {
    *this = ::std::move(from);
  }

  inline RangeFilter& operator=(const RangeFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeFilter& operator=(RangeFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangeFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangeFilter* internal_default_instance() {
    return reinterpret_cast<const RangeFilter*>(
               &_RangeFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RangeFilter& a, RangeFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(RangeFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangeFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangeFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RangeFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RangeFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RangeFilter& from) {
    RangeFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangeFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.RangeFilter";
  }
  protected:
  explicit RangeFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
    kLowerValueFieldNumber = 2,
    kUpperValueFieldNumber = 3,
    kIncludeLowerFieldNumber = 4,
    kIncludeUpperFieldNumber = 5,
    kIsUnionFieldNumber = 6,
  };
  // string field = 1;
  void clear_field();
  const std::string& field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field();
  PROTOBUF_NODISCARD std::string* release_field();
  void set_allocated_field(std::string* field);
  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(const std::string& value);
  std::string* _internal_mutable_field();
  public:

  // bytes lower_value = 2;
  void clear_lower_value();
  const std::string& lower_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lower_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lower_value();
  PROTOBUF_NODISCARD std::string* release_lower_value();
  void set_allocated_lower_value(std::string* lower_value);
  private:
  const std::string& _internal_lower_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lower_value(const std::string& value);
  std::string* _internal_mutable_lower_value();
  public:

  // bytes upper_value = 3;
  void clear_upper_value();
  const std::string& upper_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_upper_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_upper_value();
  PROTOBUF_NODISCARD std::string* release_upper_value();
  void set_allocated_upper_value(std::string* upper_value);
  private:
  const std::string& _internal_upper_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_upper_value(const std::string& value);
  std::string* _internal_mutable_upper_value();
  public:

  // bool include_lower = 4;
  void clear_include_lower();
  bool include_lower() const;
  void set_include_lower(bool value);
  private:
  bool _internal_include_lower() const;
  void _internal_set_include_lower(bool value);
  public:

  // bool include_upper = 5;
  void clear_include_upper();
  bool include_upper() const;
  void set_include_upper(bool value);
  private:
  bool _internal_include_upper() const;
  void _internal_set_include_upper(bool value);
  public:

  // int32 is_union = 6;
  void clear_is_union();
  int32_t is_union() const;
  void set_is_union(int32_t value);
  private:
  int32_t _internal_is_union() const;
  void _internal_set_is_union(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vearchpb.RangeFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lower_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr upper_value_;
    bool include_lower_;
    bool include_upper_;
    int32_t is_union_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class SortField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.SortField) */ {
 public:
  inline SortField() : SortField(nullptr) {}
  ~SortField() override;
  explicit PROTOBUF_CONSTEXPR SortField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SortField(const SortField& from);
  SortField(SortField&& from) noexcept
    : SortField() {
    *this = ::std::move(from);
  }

  inline SortField& operator=(const SortField& from) {
    CopyFrom(from);
    return *this;
  }
  inline SortField& operator=(SortField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SortField& default_instance() {
    return *internal_default_instance();
  }
  static inline const SortField* internal_default_instance() {
    return reinterpret_cast<const SortField*>(
               &_SortField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SortField& a, SortField& b) {
    a.Swap(&b);
  }
  inline void Swap(SortField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SortField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SortField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SortField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SortField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SortField& from) {
    SortField::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SortField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.SortField";
  }
  protected:
  explicit SortField(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string field = 1;
  void clear_field();
  const std::string& field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field();
  PROTOBUF_NODISCARD std::string* release_field();
  void set_allocated_field(std::string* field);
  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(const std::string& value);
  std::string* _internal_mutable_field();
  public:

  // bool type = 2;
  void clear_type();
  bool type() const;
  void set_type(bool value);
  private:
  bool _internal_type() const;
  void _internal_set_type(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vearchpb.SortField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_;
    bool type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class VectorQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.VectorQuery) */ {
 public:
  inline VectorQuery() : VectorQuery(nullptr) {}
  ~VectorQuery() override;
  explicit PROTOBUF_CONSTEXPR VectorQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VectorQuery(const VectorQuery& from);
  VectorQuery(VectorQuery&& from) noexcept
    : VectorQuery() {
    *this = ::std::move(from);
  }

  inline VectorQuery& operator=(const VectorQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorQuery& operator=(VectorQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorQuery* internal_default_instance() {
    return reinterpret_cast<const VectorQuery*>(
               &_VectorQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(VectorQuery& a, VectorQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VectorQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VectorQuery& from) {
    VectorQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.VectorQuery";
  }
  protected:
  explicit VectorQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
    kFormatFieldNumber = 5,
    kIndexTypeFieldNumber = 6,
    kMinScoreFieldNumber = 3,
    kMaxScoreFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string format = 5;
  void clear_format();
  const std::string& format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* format);
  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(const std::string& value);
  std::string* _internal_mutable_format();
  public:

  // string index_type = 6;
  void clear_index_type();
  const std::string& index_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index_type();
  PROTOBUF_NODISCARD std::string* release_index_type();
  void set_allocated_index_type(std::string* index_type);
  private:
  const std::string& _internal_index_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index_type(const std::string& value);
  std::string* _internal_mutable_index_type();
  public:

  // double min_score = 3;
  void clear_min_score();
  double min_score() const;
  void set_min_score(double value);
  private:
  double _internal_min_score() const;
  void _internal_set_min_score(double value);
  public:

  // double max_score = 4;
  void clear_max_score();
  double max_score() const;
  void set_max_score(double value);
  private:
  double _internal_max_score() const;
  void _internal_set_max_score(double value);
  public:

  // @@protoc_insertion_point(class_scope:vearchpb.VectorQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_type_;
    double min_score_;
    double max_score_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class IndexParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.IndexParameters) */ {
 public:
  inline IndexParameters() : IndexParameters(nullptr) {}
  ~IndexParameters() override;
  explicit PROTOBUF_CONSTEXPR IndexParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndexParameters(const IndexParameters& from);
  IndexParameters(IndexParameters&& from) noexcept
    : IndexParameters() {
    *this = ::std::move(from);
  }

  inline IndexParameters& operator=(const IndexParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexParameters& operator=(IndexParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndexParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndexParameters* internal_default_instance() {
    return reinterpret_cast<const IndexParameters*>(
               &_IndexParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(IndexParameters& a, IndexParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IndexParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IndexParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndexParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IndexParameters& from) {
    IndexParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.IndexParameters";
  }
  protected:
  explicit IndexParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef IndexParameters_DistanceMetricType DistanceMetricType;
  static constexpr DistanceMetricType InnerProduct =
    IndexParameters_DistanceMetricType_InnerProduct;
  static constexpr DistanceMetricType L2 =
    IndexParameters_DistanceMetricType_L2;
  static inline bool DistanceMetricType_IsValid(int value) {
    return IndexParameters_DistanceMetricType_IsValid(value);
  }
  static constexpr DistanceMetricType DistanceMetricType_MIN =
    IndexParameters_DistanceMetricType_DistanceMetricType_MIN;
  static constexpr DistanceMetricType DistanceMetricType_MAX =
    IndexParameters_DistanceMetricType_DistanceMetricType_MAX;
  static constexpr int DistanceMetricType_ARRAYSIZE =
    IndexParameters_DistanceMetricType_DistanceMetricType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DistanceMetricType_descriptor() {
    return IndexParameters_DistanceMetricType_descriptor();
  }
  template<typename T>
  static inline const std::string& DistanceMetricType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DistanceMetricType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DistanceMetricType_Name.");
    return IndexParameters_DistanceMetricType_Name(enum_t_value);
  }
  static inline bool DistanceMetricType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DistanceMetricType* value) {
    return IndexParameters_DistanceMetricType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMetricTypeFieldNumber = 1,
    kNprobeFieldNumber = 2,
  };
  // .vearchpb.IndexParameters.DistanceMetricType metric_type = 1;
  void clear_metric_type();
  ::vearchpb::IndexParameters_DistanceMetricType metric_type() const;
  void set_metric_type(::vearchpb::IndexParameters_DistanceMetricType value);
  private:
  ::vearchpb::IndexParameters_DistanceMetricType _internal_metric_type() const;
  void _internal_set_metric_type(::vearchpb::IndexParameters_DistanceMetricType value);
  public:

  // int32 nprobe = 2;
  void clear_nprobe();
  int32_t nprobe() const;
  void set_nprobe(int32_t value);
  private:
  int32_t _internal_nprobe() const;
  void _internal_set_nprobe(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vearchpb.IndexParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int metric_type_;
    int32_t nprobe_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class QueryRequest_SortFieldMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<QueryRequest_SortFieldMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<QueryRequest_SortFieldMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  QueryRequest_SortFieldMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR QueryRequest_SortFieldMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit QueryRequest_SortFieldMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const QueryRequest_SortFieldMapEntry_DoNotUse& other);
  static const QueryRequest_SortFieldMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const QueryRequest_SortFieldMapEntry_DoNotUse*>(&_QueryRequest_SortFieldMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vearchpb.QueryRequest.SortFieldMapEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vearchpb.QueryRequest.SortFieldMapEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};

// -------------------------------------------------------------------

class QueryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.QueryRequest) */ {
 public:
  inline QueryRequest() : QueryRequest(nullptr) {}
  ~QueryRequest() override;
  explicit PROTOBUF_CONSTEXPR QueryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryRequest(const QueryRequest& from);
  QueryRequest(QueryRequest&& from) noexcept
    : QueryRequest() {
    *this = ::std::move(from);
  }

  inline QueryRequest& operator=(const QueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryRequest& operator=(QueryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryRequest* internal_default_instance() {
    return reinterpret_cast<const QueryRequest*>(
               &_QueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(QueryRequest& a, QueryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryRequest& from) {
    QueryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.QueryRequest";
  }
  protected:
  explicit QueryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDocumentIdsFieldNumber = 2,
    kRangeFiltersFieldNumber = 5,
    kTermFiltersFieldNumber = 6,
    kFieldsFieldNumber = 7,
    kSortFieldMapFieldNumber = 12,
    kSortFieldsFieldNumber = 13,
    kLoadBalanceFieldNumber = 11,
    kHeadFieldNumber = 1,
    kPartitionIdFieldNumber = 3,
    kNextFieldNumber = 4,
    kIsVectorValueFieldNumber = 8,
    kTraceFieldNumber = 14,
    kLimitFieldNumber = 9,
    kPageSizeFieldNumber = 10,
    kOperatorFieldNumber = 15,
  };
  // repeated string document_ids = 2;
  int document_ids_size() const;
  private:
  int _internal_document_ids_size() const;
  public:
  void clear_document_ids();
  const std::string& document_ids(int index) const;
  std::string* mutable_document_ids(int index);
  void set_document_ids(int index, const std::string& value);
  void set_document_ids(int index, std::string&& value);
  void set_document_ids(int index, const char* value);
  void set_document_ids(int index, const char* value, size_t size);
  std::string* add_document_ids();
  void add_document_ids(const std::string& value);
  void add_document_ids(std::string&& value);
  void add_document_ids(const char* value);
  void add_document_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& document_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_document_ids();
  private:
  const std::string& _internal_document_ids(int index) const;
  std::string* _internal_add_document_ids();
  public:

  // repeated .vearchpb.RangeFilter range_filters = 5;
  int range_filters_size() const;
  private:
  int _internal_range_filters_size() const;
  public:
  void clear_range_filters();
  ::vearchpb::RangeFilter* mutable_range_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::RangeFilter >*
      mutable_range_filters();
  private:
  const ::vearchpb::RangeFilter& _internal_range_filters(int index) const;
  ::vearchpb::RangeFilter* _internal_add_range_filters();
  public:
  const ::vearchpb::RangeFilter& range_filters(int index) const;
  ::vearchpb::RangeFilter* add_range_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::RangeFilter >&
      range_filters() const;

  // repeated .vearchpb.TermFilter term_filters = 6;
  int term_filters_size() const;
  private:
  int _internal_term_filters_size() const;
  public:
  void clear_term_filters();
  ::vearchpb::TermFilter* mutable_term_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::TermFilter >*
      mutable_term_filters();
  private:
  const ::vearchpb::TermFilter& _internal_term_filters(int index) const;
  ::vearchpb::TermFilter* _internal_add_term_filters();
  public:
  const ::vearchpb::TermFilter& term_filters(int index) const;
  ::vearchpb::TermFilter* add_term_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::TermFilter >&
      term_filters() const;

  // repeated string fields = 7;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  const std::string& fields(int index) const;
  std::string* mutable_fields(int index);
  void set_fields(int index, const std::string& value);
  void set_fields(int index, std::string&& value);
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  std::string* add_fields();
  void add_fields(const std::string& value);
  void add_fields(std::string&& value);
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& fields() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_fields();
  private:
  const std::string& _internal_fields(int index) const;
  std::string* _internal_add_fields();
  public:

  // map<string, string> sort_field_map = 12;
  int sort_field_map_size() const;
  private:
  int _internal_sort_field_map_size() const;
  public:
  void clear_sort_field_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_sort_field_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_sort_field_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      sort_field_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_sort_field_map();

  // repeated .vearchpb.SortField sort_fields = 13;
  int sort_fields_size() const;
  private:
  int _internal_sort_fields_size() const;
  public:
  void clear_sort_fields();
  ::vearchpb::SortField* mutable_sort_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::SortField >*
      mutable_sort_fields();
  private:
  const ::vearchpb::SortField& _internal_sort_fields(int index) const;
  ::vearchpb::SortField* _internal_add_sort_fields();
  public:
  const ::vearchpb::SortField& sort_fields(int index) const;
  ::vearchpb::SortField* add_sort_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::SortField >&
      sort_fields() const;

  // string load_balance = 11;
  void clear_load_balance();
  const std::string& load_balance() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_load_balance(ArgT0&& arg0, ArgT... args);
  std::string* mutable_load_balance();
  PROTOBUF_NODISCARD std::string* release_load_balance();
  void set_allocated_load_balance(std::string* load_balance);
  private:
  const std::string& _internal_load_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_load_balance(const std::string& value);
  std::string* _internal_mutable_load_balance();
  public:

  // .vearchpb.RequestHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::vearchpb::RequestHead& head() const;
  PROTOBUF_NODISCARD ::vearchpb::RequestHead* release_head();
  ::vearchpb::RequestHead* mutable_head();
  void set_allocated_head(::vearchpb::RequestHead* head);
  private:
  const ::vearchpb::RequestHead& _internal_head() const;
  ::vearchpb::RequestHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::vearchpb::RequestHead* head);
  ::vearchpb::RequestHead* unsafe_arena_release_head();

  // int32 partition_id = 3;
  void clear_partition_id();
  int32_t partition_id() const;
  void set_partition_id(int32_t value);
  private:
  int32_t _internal_partition_id() const;
  void _internal_set_partition_id(int32_t value);
  public:

  // bool next = 4;
  void clear_next();
  bool next() const;
  void set_next(bool value);
  private:
  bool _internal_next() const;
  void _internal_set_next(bool value);
  public:

  // bool is_vector_value = 8;
  void clear_is_vector_value();
  bool is_vector_value() const;
  void set_is_vector_value(bool value);
  private:
  bool _internal_is_vector_value() const;
  void _internal_set_is_vector_value(bool value);
  public:

  // bool trace = 14;
  void clear_trace();
  bool trace() const;
  void set_trace(bool value);
  private:
  bool _internal_trace() const;
  void _internal_set_trace(bool value);
  public:

  // int32 limit = 9;
  void clear_limit();
  int32_t limit() const;
  void set_limit(int32_t value);
  private:
  int32_t _internal_limit() const;
  void _internal_set_limit(int32_t value);
  public:

  // int32 page_size = 10;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // int32 operator = 15;
  void clear_operator_();
  int32_t operator_() const;
  void set_operator_(int32_t value);
  private:
  int32_t _internal_operator_() const;
  void _internal_set_operator_(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vearchpb.QueryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> document_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::RangeFilter > range_filters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::TermFilter > term_filters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> fields_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        QueryRequest_SortFieldMapEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> sort_field_map_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::SortField > sort_fields_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr load_balance_;
    ::vearchpb::RequestHead* head_;
    int32_t partition_id_;
    bool next_;
    bool is_vector_value_;
    bool trace_;
    int32_t limit_;
    int32_t page_size_;
    int32_t operator__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class SearchRequest_SortFieldMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SearchRequest_SortFieldMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SearchRequest_SortFieldMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  SearchRequest_SortFieldMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SearchRequest_SortFieldMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SearchRequest_SortFieldMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SearchRequest_SortFieldMapEntry_DoNotUse& other);
  static const SearchRequest_SortFieldMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SearchRequest_SortFieldMapEntry_DoNotUse*>(&_SearchRequest_SortFieldMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vearchpb.SearchRequest.SortFieldMapEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vearchpb.SearchRequest.SortFieldMapEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};

// -------------------------------------------------------------------

class SearchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.SearchRequest) */ {
 public:
  inline SearchRequest() : SearchRequest(nullptr) {}
  ~SearchRequest() override;
  explicit PROTOBUF_CONSTEXPR SearchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchRequest(const SearchRequest& from);
  SearchRequest(SearchRequest&& from) noexcept
    : SearchRequest() {
    *this = ::std::move(from);
  }

  inline SearchRequest& operator=(const SearchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchRequest& operator=(SearchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchRequest* internal_default_instance() {
    return reinterpret_cast<const SearchRequest*>(
               &_SearchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SearchRequest& a, SearchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchRequest& from) {
    SearchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.SearchRequest";
  }
  protected:
  explicit SearchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVecFieldsFieldNumber = 5,
    kFieldsFieldNumber = 6,
    kRangeFiltersFieldNumber = 7,
    kTermFiltersFieldNumber = 8,
    kSortFieldMapFieldNumber = 13,
    kSortFieldsFieldNumber = 14,
    kIndexParamsFieldNumber = 9,
    kRankerFieldNumber = 15,
    kHeadFieldNumber = 1,
    kReqNumFieldNumber = 2,
    kTopNFieldNumber = 3,
    kIsBruteSearchFieldNumber = 4,
    kMultiVectorRankFieldNumber = 10,
    kL2SqrtFieldNumber = 11,
    kIsVectorValueFieldNumber = 12,
    kTraceFieldNumber = 16,
    kOperatorFieldNumber = 17,
  };
  // repeated .vearchpb.VectorQuery vec_fields = 5;
  int vec_fields_size() const;
  private:
  int _internal_vec_fields_size() const;
  public:
  void clear_vec_fields();
  ::vearchpb::VectorQuery* mutable_vec_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::VectorQuery >*
      mutable_vec_fields();
  private:
  const ::vearchpb::VectorQuery& _internal_vec_fields(int index) const;
  ::vearchpb::VectorQuery* _internal_add_vec_fields();
  public:
  const ::vearchpb::VectorQuery& vec_fields(int index) const;
  ::vearchpb::VectorQuery* add_vec_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::VectorQuery >&
      vec_fields() const;

  // repeated string fields = 6;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  const std::string& fields(int index) const;
  std::string* mutable_fields(int index);
  void set_fields(int index, const std::string& value);
  void set_fields(int index, std::string&& value);
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  std::string* add_fields();
  void add_fields(const std::string& value);
  void add_fields(std::string&& value);
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& fields() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_fields();
  private:
  const std::string& _internal_fields(int index) const;
  std::string* _internal_add_fields();
  public:

  // repeated .vearchpb.RangeFilter range_filters = 7;
  int range_filters_size() const;
  private:
  int _internal_range_filters_size() const;
  public:
  void clear_range_filters();
  ::vearchpb::RangeFilter* mutable_range_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::RangeFilter >*
      mutable_range_filters();
  private:
  const ::vearchpb::RangeFilter& _internal_range_filters(int index) const;
  ::vearchpb::RangeFilter* _internal_add_range_filters();
  public:
  const ::vearchpb::RangeFilter& range_filters(int index) const;
  ::vearchpb::RangeFilter* add_range_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::RangeFilter >&
      range_filters() const;

  // repeated .vearchpb.TermFilter term_filters = 8;
  int term_filters_size() const;
  private:
  int _internal_term_filters_size() const;
  public:
  void clear_term_filters();
  ::vearchpb::TermFilter* mutable_term_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::TermFilter >*
      mutable_term_filters();
  private:
  const ::vearchpb::TermFilter& _internal_term_filters(int index) const;
  ::vearchpb::TermFilter* _internal_add_term_filters();
  public:
  const ::vearchpb::TermFilter& term_filters(int index) const;
  ::vearchpb::TermFilter* add_term_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::TermFilter >&
      term_filters() const;

  // map<string, string> sort_field_map = 13;
  int sort_field_map_size() const;
  private:
  int _internal_sort_field_map_size() const;
  public:
  void clear_sort_field_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_sort_field_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_sort_field_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      sort_field_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_sort_field_map();

  // repeated .vearchpb.SortField sort_fields = 14;
  int sort_fields_size() const;
  private:
  int _internal_sort_fields_size() const;
  public:
  void clear_sort_fields();
  ::vearchpb::SortField* mutable_sort_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::SortField >*
      mutable_sort_fields();
  private:
  const ::vearchpb::SortField& _internal_sort_fields(int index) const;
  ::vearchpb::SortField* _internal_add_sort_fields();
  public:
  const ::vearchpb::SortField& sort_fields(int index) const;
  ::vearchpb::SortField* add_sort_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::SortField >&
      sort_fields() const;

  // string index_params = 9;
  void clear_index_params();
  const std::string& index_params() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index_params(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index_params();
  PROTOBUF_NODISCARD std::string* release_index_params();
  void set_allocated_index_params(std::string* index_params);
  private:
  const std::string& _internal_index_params() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index_params(const std::string& value);
  std::string* _internal_mutable_index_params();
  public:

  // string ranker = 15;
  void clear_ranker();
  const std::string& ranker() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ranker(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ranker();
  PROTOBUF_NODISCARD std::string* release_ranker();
  void set_allocated_ranker(std::string* ranker);
  private:
  const std::string& _internal_ranker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ranker(const std::string& value);
  std::string* _internal_mutable_ranker();
  public:

  // .vearchpb.RequestHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::vearchpb::RequestHead& head() const;
  PROTOBUF_NODISCARD ::vearchpb::RequestHead* release_head();
  ::vearchpb::RequestHead* mutable_head();
  void set_allocated_head(::vearchpb::RequestHead* head);
  private:
  const ::vearchpb::RequestHead& _internal_head() const;
  ::vearchpb::RequestHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::vearchpb::RequestHead* head);
  ::vearchpb::RequestHead* unsafe_arena_release_head();

  // int32 req_num = 2;
  void clear_req_num();
  int32_t req_num() const;
  void set_req_num(int32_t value);
  private:
  int32_t _internal_req_num() const;
  void _internal_set_req_num(int32_t value);
  public:

  // int32 topN = 3;
  void clear_topn();
  int32_t topn() const;
  void set_topn(int32_t value);
  private:
  int32_t _internal_topn() const;
  void _internal_set_topn(int32_t value);
  public:

  // int32 is_brute_search = 4;
  void clear_is_brute_search();
  int32_t is_brute_search() const;
  void set_is_brute_search(int32_t value);
  private:
  int32_t _internal_is_brute_search() const;
  void _internal_set_is_brute_search(int32_t value);
  public:

  // int32 multi_vector_rank = 10;
  void clear_multi_vector_rank();
  int32_t multi_vector_rank() const;
  void set_multi_vector_rank(int32_t value);
  private:
  int32_t _internal_multi_vector_rank() const;
  void _internal_set_multi_vector_rank(int32_t value);
  public:

  // bool l2_sqrt = 11;
  void clear_l2_sqrt();
  bool l2_sqrt() const;
  void set_l2_sqrt(bool value);
  private:
  bool _internal_l2_sqrt() const;
  void _internal_set_l2_sqrt(bool value);
  public:

  // bool is_vector_value = 12;
  void clear_is_vector_value();
  bool is_vector_value() const;
  void set_is_vector_value(bool value);
  private:
  bool _internal_is_vector_value() const;
  void _internal_set_is_vector_value(bool value);
  public:

  // bool trace = 16;
  void clear_trace();
  bool trace() const;
  void set_trace(bool value);
  private:
  bool _internal_trace() const;
  void _internal_set_trace(bool value);
  public:

  // int32 operator = 17;
  void clear_operator_();
  int32_t operator_() const;
  void set_operator_(int32_t value);
  private:
  int32_t _internal_operator_() const;
  void _internal_set_operator_(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vearchpb.SearchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::VectorQuery > vec_fields_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> fields_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::RangeFilter > range_filters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::TermFilter > term_filters_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SearchRequest_SortFieldMapEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> sort_field_map_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::SortField > sort_fields_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_params_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ranker_;
    ::vearchpb::RequestHead* head_;
    int32_t req_num_;
    int32_t topn_;
    int32_t is_brute_search_;
    int32_t multi_vector_rank_;
    bool l2_sqrt_;
    bool is_vector_value_;
    bool trace_;
    int32_t operator__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class ResultItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.ResultItem) */ {
 public:
  inline ResultItem() : ResultItem(nullptr) {}
  ~ResultItem() override;
  explicit PROTOBUF_CONSTEXPR ResultItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResultItem(const ResultItem& from);
  ResultItem(ResultItem&& from) noexcept
    : ResultItem() {
    *this = ::std::move(from);
  }

  inline ResultItem& operator=(const ResultItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultItem& operator=(ResultItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResultItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResultItem* internal_default_instance() {
    return reinterpret_cast<const ResultItem*>(
               &_ResultItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ResultItem& a, ResultItem& b) {
    a.Swap(&b);
  }
  inline void Swap(ResultItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResultItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResultItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResultItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResultItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResultItem& from) {
    ResultItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResultItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.ResultItem";
  }
  protected:
  explicit ResultItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 2,
    kPKeyFieldNumber = 3,
    kScoreFieldNumber = 1,
  };
  // repeated .vearchpb.Field fields = 2;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::vearchpb::Field* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Field >*
      mutable_fields();
  private:
  const ::vearchpb::Field& _internal_fields(int index) const;
  ::vearchpb::Field* _internal_add_fields();
  public:
  const ::vearchpb::Field& fields(int index) const;
  ::vearchpb::Field* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Field >&
      fields() const;

  // string p_key = 3;
  void clear_p_key();
  const std::string& p_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_p_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_p_key();
  PROTOBUF_NODISCARD std::string* release_p_key();
  void set_allocated_p_key(std::string* p_key);
  private:
  const std::string& _internal_p_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_p_key(const std::string& value);
  std::string* _internal_mutable_p_key();
  public:

  // double score = 1;
  void clear_score();
  double score() const;
  void set_score(double value);
  private:
  double _internal_score() const;
  void _internal_set_score(double value);
  public:

  // @@protoc_insertion_point(class_scope:vearchpb.ResultItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Field > fields_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr p_key_;
    double score_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class SearchResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.SearchResult) */ {
 public:
  inline SearchResult() : SearchResult(nullptr) {}
  ~SearchResult() override;
  explicit PROTOBUF_CONSTEXPR SearchResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchResult(const SearchResult& from);
  SearchResult(SearchResult&& from) noexcept
    : SearchResult() {
    *this = ::std::move(from);
  }

  inline SearchResult& operator=(const SearchResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResult& operator=(SearchResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchResult* internal_default_instance() {
    return reinterpret_cast<const SearchResult*>(
               &_SearchResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SearchResult& a, SearchResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchResult& from) {
    SearchResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.SearchResult";
  }
  protected:
  explicit SearchResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultItemsFieldNumber = 7,
    kMsgFieldNumber = 6,
    kStatusFieldNumber = 5,
    kMaxScoreFieldNumber = 2,
    kTotalHitsFieldNumber = 1,
    kMaxTookIdFieldNumber = 4,
    kMaxTookFieldNumber = 3,
    kPIDFieldNumber = 8,
    kTimeoutFieldNumber = 9,
    kTopNFieldNumber = 10,
  };
  // repeated .vearchpb.ResultItem result_items = 7;
  int result_items_size() const;
  private:
  int _internal_result_items_size() const;
  public:
  void clear_result_items();
  ::vearchpb::ResultItem* mutable_result_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::ResultItem >*
      mutable_result_items();
  private:
  const ::vearchpb::ResultItem& _internal_result_items(int index) const;
  ::vearchpb::ResultItem* _internal_add_result_items();
  public:
  const ::vearchpb::ResultItem& result_items(int index) const;
  ::vearchpb::ResultItem* add_result_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::ResultItem >&
      result_items() const;

  // string msg = 6;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // .vearchpb.SearchStatus status = 5;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::vearchpb::SearchStatus& status() const;
  PROTOBUF_NODISCARD ::vearchpb::SearchStatus* release_status();
  ::vearchpb::SearchStatus* mutable_status();
  void set_allocated_status(::vearchpb::SearchStatus* status);
  private:
  const ::vearchpb::SearchStatus& _internal_status() const;
  ::vearchpb::SearchStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::vearchpb::SearchStatus* status);
  ::vearchpb::SearchStatus* unsafe_arena_release_status();

  // double max_score = 2;
  void clear_max_score();
  double max_score() const;
  void set_max_score(double value);
  private:
  double _internal_max_score() const;
  void _internal_set_max_score(double value);
  public:

  // int32 total_hits = 1;
  void clear_total_hits();
  int32_t total_hits() const;
  void set_total_hits(int32_t value);
  private:
  int32_t _internal_total_hits() const;
  void _internal_set_total_hits(int32_t value);
  public:

  // uint32 max_took_id = 4;
  void clear_max_took_id();
  uint32_t max_took_id() const;
  void set_max_took_id(uint32_t value);
  private:
  uint32_t _internal_max_took_id() const;
  void _internal_set_max_took_id(uint32_t value);
  public:

  // int64 max_took = 3;
  void clear_max_took();
  int64_t max_took() const;
  void set_max_took(int64_t value);
  private:
  int64_t _internal_max_took() const;
  void _internal_set_max_took(int64_t value);
  public:

  // uint32 pID = 8;
  void clear_pid();
  uint32_t pid() const;
  void set_pid(uint32_t value);
  private:
  uint32_t _internal_pid() const;
  void _internal_set_pid(uint32_t value);
  public:

  // bool timeout = 9;
  void clear_timeout();
  bool timeout() const;
  void set_timeout(bool value);
  private:
  bool _internal_timeout() const;
  void _internal_set_timeout(bool value);
  public:

  // int32 topN = 10;
  void clear_topn();
  int32_t topn() const;
  void set_topn(int32_t value);
  private:
  int32_t _internal_topn() const;
  void _internal_set_topn(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vearchpb.SearchResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::ResultItem > result_items_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::vearchpb::SearchStatus* status_;
    double max_score_;
    int32_t total_hits_;
    uint32_t max_took_id_;
    int64_t max_took_;
    uint32_t pid_;
    bool timeout_;
    int32_t topn_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class SearchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.SearchResponse) */ {
 public:
  inline SearchResponse() : SearchResponse(nullptr) {}
  ~SearchResponse() override;
  explicit PROTOBUF_CONSTEXPR SearchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchResponse(const SearchResponse& from);
  SearchResponse(SearchResponse&& from) noexcept
    : SearchResponse() {
    *this = ::std::move(from);
  }

  inline SearchResponse& operator=(const SearchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResponse& operator=(SearchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchResponse* internal_default_instance() {
    return reinterpret_cast<const SearchResponse*>(
               &_SearchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SearchResponse& a, SearchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchResponse& from) {
    SearchResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.SearchResponse";
  }
  protected:
  explicit SearchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 2,
    kFlatBytesFieldNumber = 4,
    kHeadFieldNumber = 1,
    kTimeoutFieldNumber = 3,
  };
  // repeated .vearchpb.SearchResult results = 2;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::vearchpb::SearchResult* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::SearchResult >*
      mutable_results();
  private:
  const ::vearchpb::SearchResult& _internal_results(int index) const;
  ::vearchpb::SearchResult* _internal_add_results();
  public:
  const ::vearchpb::SearchResult& results(int index) const;
  ::vearchpb::SearchResult* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::SearchResult >&
      results() const;

  // bytes FlatBytes = 4;
  void clear_flatbytes();
  const std::string& flatbytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_flatbytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_flatbytes();
  PROTOBUF_NODISCARD std::string* release_flatbytes();
  void set_allocated_flatbytes(std::string* flatbytes);
  private:
  const std::string& _internal_flatbytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flatbytes(const std::string& value);
  std::string* _internal_mutable_flatbytes();
  public:

  // .vearchpb.ResponseHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::vearchpb::ResponseHead& head() const;
  PROTOBUF_NODISCARD ::vearchpb::ResponseHead* release_head();
  ::vearchpb::ResponseHead* mutable_head();
  void set_allocated_head(::vearchpb::ResponseHead* head);
  private:
  const ::vearchpb::ResponseHead& _internal_head() const;
  ::vearchpb::ResponseHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::vearchpb::ResponseHead* head);
  ::vearchpb::ResponseHead* unsafe_arena_release_head();

  // bool timeout = 3;
  void clear_timeout();
  bool timeout() const;
  void set_timeout(bool value);
  private:
  bool _internal_timeout() const;
  void _internal_set_timeout(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vearchpb.SearchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::SearchResult > results_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flatbytes_;
    ::vearchpb::ResponseHead* head_;
    bool timeout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class SearchStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vearchpb.SearchStatus) */ {
 public:
  inline SearchStatus() : SearchStatus(nullptr) {}
  ~SearchStatus() override;
  explicit PROTOBUF_CONSTEXPR SearchStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchStatus(const SearchStatus& from);
  SearchStatus(SearchStatus&& from) noexcept
    : SearchStatus() {
    *this = ::std::move(from);
  }

  inline SearchStatus& operator=(const SearchStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchStatus& operator=(SearchStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchStatus* internal_default_instance() {
    return reinterpret_cast<const SearchStatus*>(
               &_SearchStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(SearchStatus& a, SearchStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchStatus& from) {
    SearchStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vearchpb.SearchStatus";
  }
  protected:
  explicit SearchStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 4,
    kTotalFieldNumber = 1,
    kFailedFieldNumber = 2,
    kSuccessfulFieldNumber = 3,
  };
  // string msg = 4;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // int32 total = 1;
  void clear_total();
  int32_t total() const;
  void set_total(int32_t value);
  private:
  int32_t _internal_total() const;
  void _internal_set_total(int32_t value);
  public:

  // int32 failed = 2;
  void clear_failed();
  int32_t failed() const;
  void set_failed(int32_t value);
  private:
  int32_t _internal_failed() const;
  void _internal_set_failed(int32_t value);
  public:

  // int32 successful = 3;
  void clear_successful();
  int32_t successful() const;
  void set_successful(int32_t value);
  private:
  int32_t _internal_successful() const;
  void _internal_set_successful(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vearchpb.SearchStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    int32_t total_;
    int32_t failed_;
    int32_t successful_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fgrpc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RequestHead

// int64 time_out_ms = 1;
inline void RequestHead::clear_time_out_ms() {
  _impl_.time_out_ms_ = int64_t{0};
}
inline int64_t RequestHead::_internal_time_out_ms() const {
  return _impl_.time_out_ms_;
}
inline int64_t RequestHead::time_out_ms() const {
  // @@protoc_insertion_point(field_get:vearchpb.RequestHead.time_out_ms)
  return _internal_time_out_ms();
}
inline void RequestHead::_internal_set_time_out_ms(int64_t value) {
  
  _impl_.time_out_ms_ = value;
}
inline void RequestHead::set_time_out_ms(int64_t value) {
  _internal_set_time_out_ms(value);
  // @@protoc_insertion_point(field_set:vearchpb.RequestHead.time_out_ms)
}

// string user_name = 2;
inline void RequestHead::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& RequestHead::user_name() const {
  // @@protoc_insertion_point(field_get:vearchpb.RequestHead.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestHead::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.RequestHead.user_name)
}
inline std::string* RequestHead::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:vearchpb.RequestHead.user_name)
  return _s;
}
inline const std::string& RequestHead::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void RequestHead::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestHead::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestHead::release_user_name() {
  // @@protoc_insertion_point(field_release:vearchpb.RequestHead.user_name)
  return _impl_.user_name_.Release();
}
inline void RequestHead::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.RequestHead.user_name)
}

// string password = 3;
inline void RequestHead::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& RequestHead::password() const {
  // @@protoc_insertion_point(field_get:vearchpb.RequestHead.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestHead::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.RequestHead.password)
}
inline std::string* RequestHead::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:vearchpb.RequestHead.password)
  return _s;
}
inline const std::string& RequestHead::_internal_password() const {
  return _impl_.password_.Get();
}
inline void RequestHead::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestHead::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestHead::release_password() {
  // @@protoc_insertion_point(field_release:vearchpb.RequestHead.password)
  return _impl_.password_.Release();
}
inline void RequestHead::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.RequestHead.password)
}

// string db_name = 4;
inline void RequestHead::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& RequestHead::db_name() const {
  // @@protoc_insertion_point(field_get:vearchpb.RequestHead.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestHead::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.RequestHead.db_name)
}
inline std::string* RequestHead::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:vearchpb.RequestHead.db_name)
  return _s;
}
inline const std::string& RequestHead::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void RequestHead::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestHead::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestHead::release_db_name() {
  // @@protoc_insertion_point(field_release:vearchpb.RequestHead.db_name)
  return _impl_.db_name_.Release();
}
inline void RequestHead::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.RequestHead.db_name)
}

// string space_name = 5;
inline void RequestHead::clear_space_name() {
  _impl_.space_name_.ClearToEmpty();
}
inline const std::string& RequestHead::space_name() const {
  // @@protoc_insertion_point(field_get:vearchpb.RequestHead.space_name)
  return _internal_space_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestHead::set_space_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.space_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.RequestHead.space_name)
}
inline std::string* RequestHead::mutable_space_name() {
  std::string* _s = _internal_mutable_space_name();
  // @@protoc_insertion_point(field_mutable:vearchpb.RequestHead.space_name)
  return _s;
}
inline const std::string& RequestHead::_internal_space_name() const {
  return _impl_.space_name_.Get();
}
inline void RequestHead::_internal_set_space_name(const std::string& value) {
  
  _impl_.space_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestHead::_internal_mutable_space_name() {
  
  return _impl_.space_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestHead::release_space_name() {
  // @@protoc_insertion_point(field_release:vearchpb.RequestHead.space_name)
  return _impl_.space_name_.Release();
}
inline void RequestHead::set_allocated_space_name(std::string* space_name) {
  if (space_name != nullptr) {
    
  } else {
    
  }
  _impl_.space_name_.SetAllocated(space_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.space_name_.IsDefault()) {
    _impl_.space_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.RequestHead.space_name)
}

// string client_type = 6;
inline void RequestHead::clear_client_type() {
  _impl_.client_type_.ClearToEmpty();
}
inline const std::string& RequestHead::client_type() const {
  // @@protoc_insertion_point(field_get:vearchpb.RequestHead.client_type)
  return _internal_client_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestHead::set_client_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.RequestHead.client_type)
}
inline std::string* RequestHead::mutable_client_type() {
  std::string* _s = _internal_mutable_client_type();
  // @@protoc_insertion_point(field_mutable:vearchpb.RequestHead.client_type)
  return _s;
}
inline const std::string& RequestHead::_internal_client_type() const {
  return _impl_.client_type_.Get();
}
inline void RequestHead::_internal_set_client_type(const std::string& value) {
  
  _impl_.client_type_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestHead::_internal_mutable_client_type() {
  
  return _impl_.client_type_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestHead::release_client_type() {
  // @@protoc_insertion_point(field_release:vearchpb.RequestHead.client_type)
  return _impl_.client_type_.Release();
}
inline void RequestHead::set_allocated_client_type(std::string* client_type) {
  if (client_type != nullptr) {
    
  } else {
    
  }
  _impl_.client_type_.SetAllocated(client_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_type_.IsDefault()) {
    _impl_.client_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.RequestHead.client_type)
}

// map<string, string> params = 7;
inline int RequestHead::_internal_params_size() const {
  return _impl_.params_.size();
}
inline int RequestHead::params_size() const {
  return _internal_params_size();
}
inline void RequestHead::clear_params() {
  _impl_.params_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RequestHead::_internal_params() const {
  return _impl_.params_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RequestHead::params() const {
  // @@protoc_insertion_point(field_map:vearchpb.RequestHead.params)
  return _internal_params();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RequestHead::_internal_mutable_params() {
  return _impl_.params_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RequestHead::mutable_params() {
  // @@protoc_insertion_point(field_mutable_map:vearchpb.RequestHead.params)
  return _internal_mutable_params();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ResponseHead

// string request_id = 1;
inline void ResponseHead::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& ResponseHead::request_id() const {
  // @@protoc_insertion_point(field_get:vearchpb.ResponseHead.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseHead::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.ResponseHead.request_id)
}
inline std::string* ResponseHead::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:vearchpb.ResponseHead.request_id)
  return _s;
}
inline const std::string& ResponseHead::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void ResponseHead::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseHead::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseHead::release_request_id() {
  // @@protoc_insertion_point(field_release:vearchpb.ResponseHead.request_id)
  return _impl_.request_id_.Release();
}
inline void ResponseHead::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.ResponseHead.request_id)
}

// .vearchpb.Error err = 2;
inline bool ResponseHead::_internal_has_err() const {
  return this != internal_default_instance() && _impl_.err_ != nullptr;
}
inline bool ResponseHead::has_err() const {
  return _internal_has_err();
}
inline const ::vearchpb::Error& ResponseHead::_internal_err() const {
  const ::vearchpb::Error* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::Error&>(
      ::vearchpb::_Error_default_instance_);
}
inline const ::vearchpb::Error& ResponseHead::err() const {
  // @@protoc_insertion_point(field_get:vearchpb.ResponseHead.err)
  return _internal_err();
}
inline void ResponseHead::unsafe_arena_set_allocated_err(
    ::vearchpb::Error* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.ResponseHead.err)
}
inline ::vearchpb::Error* ResponseHead::release_err() {
  
  ::vearchpb::Error* temp = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::Error* ResponseHead::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:vearchpb.ResponseHead.err)
  
  ::vearchpb::Error* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::vearchpb::Error* ResponseHead::_internal_mutable_err() {
  
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::Error>(GetArenaForAllocation());
    _impl_.err_ = p;
  }
  return _impl_.err_;
}
inline ::vearchpb::Error* ResponseHead::mutable_err() {
  ::vearchpb::Error* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:vearchpb.ResponseHead.err)
  return _msg;
}
inline void ResponseHead::set_allocated_err(::vearchpb::Error* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err));
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.err_ = err;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.ResponseHead.err)
}

// map<string, string> params = 3;
inline int ResponseHead::_internal_params_size() const {
  return _impl_.params_.size();
}
inline int ResponseHead::params_size() const {
  return _internal_params_size();
}
inline void ResponseHead::clear_params() {
  _impl_.params_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ResponseHead::_internal_params() const {
  return _impl_.params_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ResponseHead::params() const {
  // @@protoc_insertion_point(field_map:vearchpb.ResponseHead.params)
  return _internal_params();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ResponseHead::_internal_mutable_params() {
  return _impl_.params_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ResponseHead::mutable_params() {
  // @@protoc_insertion_point(field_mutable_map:vearchpb.ResponseHead.params)
  return _internal_mutable_params();
}

// -------------------------------------------------------------------

// GetRequest

// .vearchpb.RequestHead head = 1;
inline bool GetRequest::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool GetRequest::has_head() const {
  return _internal_has_head();
}
inline void GetRequest::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::vearchpb::RequestHead& GetRequest::_internal_head() const {
  const ::vearchpb::RequestHead* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::RequestHead&>(
      ::vearchpb::_RequestHead_default_instance_);
}
inline const ::vearchpb::RequestHead& GetRequest::head() const {
  // @@protoc_insertion_point(field_get:vearchpb.GetRequest.head)
  return _internal_head();
}
inline void GetRequest::unsafe_arena_set_allocated_head(
    ::vearchpb::RequestHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.GetRequest.head)
}
inline ::vearchpb::RequestHead* GetRequest::release_head() {
  
  ::vearchpb::RequestHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::RequestHead* GetRequest::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:vearchpb.GetRequest.head)
  
  ::vearchpb::RequestHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::vearchpb::RequestHead* GetRequest::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::RequestHead>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::vearchpb::RequestHead* GetRequest::mutable_head() {
  ::vearchpb::RequestHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:vearchpb.GetRequest.head)
  return _msg;
}
inline void GetRequest::set_allocated_head(::vearchpb::RequestHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.GetRequest.head)
}

// repeated string primary_keys = 2;
inline int GetRequest::_internal_primary_keys_size() const {
  return _impl_.primary_keys_.size();
}
inline int GetRequest::primary_keys_size() const {
  return _internal_primary_keys_size();
}
inline void GetRequest::clear_primary_keys() {
  _impl_.primary_keys_.Clear();
}
inline std::string* GetRequest::add_primary_keys() {
  std::string* _s = _internal_add_primary_keys();
  // @@protoc_insertion_point(field_add_mutable:vearchpb.GetRequest.primary_keys)
  return _s;
}
inline const std::string& GetRequest::_internal_primary_keys(int index) const {
  return _impl_.primary_keys_.Get(index);
}
inline const std::string& GetRequest::primary_keys(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.GetRequest.primary_keys)
  return _internal_primary_keys(index);
}
inline std::string* GetRequest::mutable_primary_keys(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.GetRequest.primary_keys)
  return _impl_.primary_keys_.Mutable(index);
}
inline void GetRequest::set_primary_keys(int index, const std::string& value) {
  _impl_.primary_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:vearchpb.GetRequest.primary_keys)
}
inline void GetRequest::set_primary_keys(int index, std::string&& value) {
  _impl_.primary_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:vearchpb.GetRequest.primary_keys)
}
inline void GetRequest::set_primary_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.primary_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vearchpb.GetRequest.primary_keys)
}
inline void GetRequest::set_primary_keys(int index, const char* value, size_t size) {
  _impl_.primary_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vearchpb.GetRequest.primary_keys)
}
inline std::string* GetRequest::_internal_add_primary_keys() {
  return _impl_.primary_keys_.Add();
}
inline void GetRequest::add_primary_keys(const std::string& value) {
  _impl_.primary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vearchpb.GetRequest.primary_keys)
}
inline void GetRequest::add_primary_keys(std::string&& value) {
  _impl_.primary_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vearchpb.GetRequest.primary_keys)
}
inline void GetRequest::add_primary_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.primary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vearchpb.GetRequest.primary_keys)
}
inline void GetRequest::add_primary_keys(const char* value, size_t size) {
  _impl_.primary_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vearchpb.GetRequest.primary_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetRequest::primary_keys() const {
  // @@protoc_insertion_point(field_list:vearchpb.GetRequest.primary_keys)
  return _impl_.primary_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetRequest::mutable_primary_keys() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.GetRequest.primary_keys)
  return &_impl_.primary_keys_;
}

// -------------------------------------------------------------------

// DeleteRequest

// .vearchpb.RequestHead head = 1;
inline bool DeleteRequest::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool DeleteRequest::has_head() const {
  return _internal_has_head();
}
inline void DeleteRequest::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::vearchpb::RequestHead& DeleteRequest::_internal_head() const {
  const ::vearchpb::RequestHead* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::RequestHead&>(
      ::vearchpb::_RequestHead_default_instance_);
}
inline const ::vearchpb::RequestHead& DeleteRequest::head() const {
  // @@protoc_insertion_point(field_get:vearchpb.DeleteRequest.head)
  return _internal_head();
}
inline void DeleteRequest::unsafe_arena_set_allocated_head(
    ::vearchpb::RequestHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.DeleteRequest.head)
}
inline ::vearchpb::RequestHead* DeleteRequest::release_head() {
  
  ::vearchpb::RequestHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::RequestHead* DeleteRequest::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:vearchpb.DeleteRequest.head)
  
  ::vearchpb::RequestHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::vearchpb::RequestHead* DeleteRequest::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::RequestHead>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::vearchpb::RequestHead* DeleteRequest::mutable_head() {
  ::vearchpb::RequestHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:vearchpb.DeleteRequest.head)
  return _msg;
}
inline void DeleteRequest::set_allocated_head(::vearchpb::RequestHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.DeleteRequest.head)
}

// repeated string primary_keys = 2;
inline int DeleteRequest::_internal_primary_keys_size() const {
  return _impl_.primary_keys_.size();
}
inline int DeleteRequest::primary_keys_size() const {
  return _internal_primary_keys_size();
}
inline void DeleteRequest::clear_primary_keys() {
  _impl_.primary_keys_.Clear();
}
inline std::string* DeleteRequest::add_primary_keys() {
  std::string* _s = _internal_add_primary_keys();
  // @@protoc_insertion_point(field_add_mutable:vearchpb.DeleteRequest.primary_keys)
  return _s;
}
inline const std::string& DeleteRequest::_internal_primary_keys(int index) const {
  return _impl_.primary_keys_.Get(index);
}
inline const std::string& DeleteRequest::primary_keys(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.DeleteRequest.primary_keys)
  return _internal_primary_keys(index);
}
inline std::string* DeleteRequest::mutable_primary_keys(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.DeleteRequest.primary_keys)
  return _impl_.primary_keys_.Mutable(index);
}
inline void DeleteRequest::set_primary_keys(int index, const std::string& value) {
  _impl_.primary_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:vearchpb.DeleteRequest.primary_keys)
}
inline void DeleteRequest::set_primary_keys(int index, std::string&& value) {
  _impl_.primary_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:vearchpb.DeleteRequest.primary_keys)
}
inline void DeleteRequest::set_primary_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.primary_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vearchpb.DeleteRequest.primary_keys)
}
inline void DeleteRequest::set_primary_keys(int index, const char* value, size_t size) {
  _impl_.primary_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vearchpb.DeleteRequest.primary_keys)
}
inline std::string* DeleteRequest::_internal_add_primary_keys() {
  return _impl_.primary_keys_.Add();
}
inline void DeleteRequest::add_primary_keys(const std::string& value) {
  _impl_.primary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vearchpb.DeleteRequest.primary_keys)
}
inline void DeleteRequest::add_primary_keys(std::string&& value) {
  _impl_.primary_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vearchpb.DeleteRequest.primary_keys)
}
inline void DeleteRequest::add_primary_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.primary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vearchpb.DeleteRequest.primary_keys)
}
inline void DeleteRequest::add_primary_keys(const char* value, size_t size) {
  _impl_.primary_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vearchpb.DeleteRequest.primary_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeleteRequest::primary_keys() const {
  // @@protoc_insertion_point(field_list:vearchpb.DeleteRequest.primary_keys)
  return _impl_.primary_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeleteRequest::mutable_primary_keys() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.DeleteRequest.primary_keys)
  return &_impl_.primary_keys_;
}

// -------------------------------------------------------------------

// BulkRequest

// .vearchpb.RequestHead head = 1;
inline bool BulkRequest::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool BulkRequest::has_head() const {
  return _internal_has_head();
}
inline void BulkRequest::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::vearchpb::RequestHead& BulkRequest::_internal_head() const {
  const ::vearchpb::RequestHead* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::RequestHead&>(
      ::vearchpb::_RequestHead_default_instance_);
}
inline const ::vearchpb::RequestHead& BulkRequest::head() const {
  // @@protoc_insertion_point(field_get:vearchpb.BulkRequest.head)
  return _internal_head();
}
inline void BulkRequest::unsafe_arena_set_allocated_head(
    ::vearchpb::RequestHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.BulkRequest.head)
}
inline ::vearchpb::RequestHead* BulkRequest::release_head() {
  
  ::vearchpb::RequestHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::RequestHead* BulkRequest::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:vearchpb.BulkRequest.head)
  
  ::vearchpb::RequestHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::vearchpb::RequestHead* BulkRequest::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::RequestHead>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::vearchpb::RequestHead* BulkRequest::mutable_head() {
  ::vearchpb::RequestHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:vearchpb.BulkRequest.head)
  return _msg;
}
inline void BulkRequest::set_allocated_head(::vearchpb::RequestHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.BulkRequest.head)
}

// repeated .vearchpb.Document docs = 2;
inline int BulkRequest::_internal_docs_size() const {
  return _impl_.docs_.size();
}
inline int BulkRequest::docs_size() const {
  return _internal_docs_size();
}
inline ::vearchpb::Document* BulkRequest::mutable_docs(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.BulkRequest.docs)
  return _impl_.docs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Document >*
BulkRequest::mutable_docs() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.BulkRequest.docs)
  return &_impl_.docs_;
}
inline const ::vearchpb::Document& BulkRequest::_internal_docs(int index) const {
  return _impl_.docs_.Get(index);
}
inline const ::vearchpb::Document& BulkRequest::docs(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.BulkRequest.docs)
  return _internal_docs(index);
}
inline ::vearchpb::Document* BulkRequest::_internal_add_docs() {
  return _impl_.docs_.Add();
}
inline ::vearchpb::Document* BulkRequest::add_docs() {
  ::vearchpb::Document* _add = _internal_add_docs();
  // @@protoc_insertion_point(field_add:vearchpb.BulkRequest.docs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Document >&
BulkRequest::docs() const {
  // @@protoc_insertion_point(field_list:vearchpb.BulkRequest.docs)
  return _impl_.docs_;
}

// repeated uint32 partitions = 3;
inline int BulkRequest::_internal_partitions_size() const {
  return _impl_.partitions_.size();
}
inline int BulkRequest::partitions_size() const {
  return _internal_partitions_size();
}
inline void BulkRequest::clear_partitions() {
  _impl_.partitions_.Clear();
}
inline uint32_t BulkRequest::_internal_partitions(int index) const {
  return _impl_.partitions_.Get(index);
}
inline uint32_t BulkRequest::partitions(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.BulkRequest.partitions)
  return _internal_partitions(index);
}
inline void BulkRequest::set_partitions(int index, uint32_t value) {
  _impl_.partitions_.Set(index, value);
  // @@protoc_insertion_point(field_set:vearchpb.BulkRequest.partitions)
}
inline void BulkRequest::_internal_add_partitions(uint32_t value) {
  _impl_.partitions_.Add(value);
}
inline void BulkRequest::add_partitions(uint32_t value) {
  _internal_add_partitions(value);
  // @@protoc_insertion_point(field_add:vearchpb.BulkRequest.partitions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
BulkRequest::_internal_partitions() const {
  return _impl_.partitions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
BulkRequest::partitions() const {
  // @@protoc_insertion_point(field_list:vearchpb.BulkRequest.partitions)
  return _internal_partitions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
BulkRequest::_internal_mutable_partitions() {
  return &_impl_.partitions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
BulkRequest::mutable_partitions() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.BulkRequest.partitions)
  return _internal_mutable_partitions();
}

// -------------------------------------------------------------------

// ForceMergeRequest

// .vearchpb.RequestHead head = 1;
inline bool ForceMergeRequest::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool ForceMergeRequest::has_head() const {
  return _internal_has_head();
}
inline void ForceMergeRequest::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::vearchpb::RequestHead& ForceMergeRequest::_internal_head() const {
  const ::vearchpb::RequestHead* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::RequestHead&>(
      ::vearchpb::_RequestHead_default_instance_);
}
inline const ::vearchpb::RequestHead& ForceMergeRequest::head() const {
  // @@protoc_insertion_point(field_get:vearchpb.ForceMergeRequest.head)
  return _internal_head();
}
inline void ForceMergeRequest::unsafe_arena_set_allocated_head(
    ::vearchpb::RequestHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.ForceMergeRequest.head)
}
inline ::vearchpb::RequestHead* ForceMergeRequest::release_head() {
  
  ::vearchpb::RequestHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::RequestHead* ForceMergeRequest::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:vearchpb.ForceMergeRequest.head)
  
  ::vearchpb::RequestHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::vearchpb::RequestHead* ForceMergeRequest::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::RequestHead>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::vearchpb::RequestHead* ForceMergeRequest::mutable_head() {
  ::vearchpb::RequestHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:vearchpb.ForceMergeRequest.head)
  return _msg;
}
inline void ForceMergeRequest::set_allocated_head(::vearchpb::RequestHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.ForceMergeRequest.head)
}

// -------------------------------------------------------------------

// FlushRequest

// .vearchpb.RequestHead head = 1;
inline bool FlushRequest::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool FlushRequest::has_head() const {
  return _internal_has_head();
}
inline void FlushRequest::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::vearchpb::RequestHead& FlushRequest::_internal_head() const {
  const ::vearchpb::RequestHead* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::RequestHead&>(
      ::vearchpb::_RequestHead_default_instance_);
}
inline const ::vearchpb::RequestHead& FlushRequest::head() const {
  // @@protoc_insertion_point(field_get:vearchpb.FlushRequest.head)
  return _internal_head();
}
inline void FlushRequest::unsafe_arena_set_allocated_head(
    ::vearchpb::RequestHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.FlushRequest.head)
}
inline ::vearchpb::RequestHead* FlushRequest::release_head() {
  
  ::vearchpb::RequestHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::RequestHead* FlushRequest::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:vearchpb.FlushRequest.head)
  
  ::vearchpb::RequestHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::vearchpb::RequestHead* FlushRequest::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::RequestHead>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::vearchpb::RequestHead* FlushRequest::mutable_head() {
  ::vearchpb::RequestHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:vearchpb.FlushRequest.head)
  return _msg;
}
inline void FlushRequest::set_allocated_head(::vearchpb::RequestHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.FlushRequest.head)
}

// -------------------------------------------------------------------

// IndexRequest

// .vearchpb.RequestHead head = 1;
inline bool IndexRequest::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool IndexRequest::has_head() const {
  return _internal_has_head();
}
inline void IndexRequest::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::vearchpb::RequestHead& IndexRequest::_internal_head() const {
  const ::vearchpb::RequestHead* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::RequestHead&>(
      ::vearchpb::_RequestHead_default_instance_);
}
inline const ::vearchpb::RequestHead& IndexRequest::head() const {
  // @@protoc_insertion_point(field_get:vearchpb.IndexRequest.head)
  return _internal_head();
}
inline void IndexRequest::unsafe_arena_set_allocated_head(
    ::vearchpb::RequestHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.IndexRequest.head)
}
inline ::vearchpb::RequestHead* IndexRequest::release_head() {
  
  ::vearchpb::RequestHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::RequestHead* IndexRequest::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:vearchpb.IndexRequest.head)
  
  ::vearchpb::RequestHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::vearchpb::RequestHead* IndexRequest::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::RequestHead>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::vearchpb::RequestHead* IndexRequest::mutable_head() {
  ::vearchpb::RequestHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:vearchpb.IndexRequest.head)
  return _msg;
}
inline void IndexRequest::set_allocated_head(::vearchpb::RequestHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.IndexRequest.head)
}

// int64 drop_before_rebuild = 2;
inline void IndexRequest::clear_drop_before_rebuild() {
  _impl_.drop_before_rebuild_ = int64_t{0};
}
inline int64_t IndexRequest::_internal_drop_before_rebuild() const {
  return _impl_.drop_before_rebuild_;
}
inline int64_t IndexRequest::drop_before_rebuild() const {
  // @@protoc_insertion_point(field_get:vearchpb.IndexRequest.drop_before_rebuild)
  return _internal_drop_before_rebuild();
}
inline void IndexRequest::_internal_set_drop_before_rebuild(int64_t value) {
  
  _impl_.drop_before_rebuild_ = value;
}
inline void IndexRequest::set_drop_before_rebuild(int64_t value) {
  _internal_set_drop_before_rebuild(value);
  // @@protoc_insertion_point(field_set:vearchpb.IndexRequest.drop_before_rebuild)
}

// int64 limit_cpu = 3;
inline void IndexRequest::clear_limit_cpu() {
  _impl_.limit_cpu_ = int64_t{0};
}
inline int64_t IndexRequest::_internal_limit_cpu() const {
  return _impl_.limit_cpu_;
}
inline int64_t IndexRequest::limit_cpu() const {
  // @@protoc_insertion_point(field_get:vearchpb.IndexRequest.limit_cpu)
  return _internal_limit_cpu();
}
inline void IndexRequest::_internal_set_limit_cpu(int64_t value) {
  
  _impl_.limit_cpu_ = value;
}
inline void IndexRequest::set_limit_cpu(int64_t value) {
  _internal_set_limit_cpu(value);
  // @@protoc_insertion_point(field_set:vearchpb.IndexRequest.limit_cpu)
}

// int64 describe = 4;
inline void IndexRequest::clear_describe() {
  _impl_.describe_ = int64_t{0};
}
inline int64_t IndexRequest::_internal_describe() const {
  return _impl_.describe_;
}
inline int64_t IndexRequest::describe() const {
  // @@protoc_insertion_point(field_get:vearchpb.IndexRequest.describe)
  return _internal_describe();
}
inline void IndexRequest::_internal_set_describe(int64_t value) {
  
  _impl_.describe_ = value;
}
inline void IndexRequest::set_describe(int64_t value) {
  _internal_set_describe(value);
  // @@protoc_insertion_point(field_set:vearchpb.IndexRequest.describe)
}

// uint32 partition_id = 5;
inline void IndexRequest::clear_partition_id() {
  _impl_.partition_id_ = 0u;
}
inline uint32_t IndexRequest::_internal_partition_id() const {
  return _impl_.partition_id_;
}
inline uint32_t IndexRequest::partition_id() const {
  // @@protoc_insertion_point(field_get:vearchpb.IndexRequest.partition_id)
  return _internal_partition_id();
}
inline void IndexRequest::_internal_set_partition_id(uint32_t value) {
  
  _impl_.partition_id_ = value;
}
inline void IndexRequest::set_partition_id(uint32_t value) {
  _internal_set_partition_id(value);
  // @@protoc_insertion_point(field_set:vearchpb.IndexRequest.partition_id)
}

// -------------------------------------------------------------------

// GetResponse

// .vearchpb.ResponseHead head = 1;
inline bool GetResponse::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool GetResponse::has_head() const {
  return _internal_has_head();
}
inline void GetResponse::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::vearchpb::ResponseHead& GetResponse::_internal_head() const {
  const ::vearchpb::ResponseHead* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::ResponseHead&>(
      ::vearchpb::_ResponseHead_default_instance_);
}
inline const ::vearchpb::ResponseHead& GetResponse::head() const {
  // @@protoc_insertion_point(field_get:vearchpb.GetResponse.head)
  return _internal_head();
}
inline void GetResponse::unsafe_arena_set_allocated_head(
    ::vearchpb::ResponseHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.GetResponse.head)
}
inline ::vearchpb::ResponseHead* GetResponse::release_head() {
  
  ::vearchpb::ResponseHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::ResponseHead* GetResponse::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:vearchpb.GetResponse.head)
  
  ::vearchpb::ResponseHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::vearchpb::ResponseHead* GetResponse::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::ResponseHead>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::vearchpb::ResponseHead* GetResponse::mutable_head() {
  ::vearchpb::ResponseHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:vearchpb.GetResponse.head)
  return _msg;
}
inline void GetResponse::set_allocated_head(::vearchpb::ResponseHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.GetResponse.head)
}

// repeated .vearchpb.Item items = 2;
inline int GetResponse::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int GetResponse::items_size() const {
  return _internal_items_size();
}
inline ::vearchpb::Item* GetResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.GetResponse.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Item >*
GetResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.GetResponse.items)
  return &_impl_.items_;
}
inline const ::vearchpb::Item& GetResponse::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::vearchpb::Item& GetResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.GetResponse.items)
  return _internal_items(index);
}
inline ::vearchpb::Item* GetResponse::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::vearchpb::Item* GetResponse::add_items() {
  ::vearchpb::Item* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:vearchpb.GetResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Item >&
GetResponse::items() const {
  // @@protoc_insertion_point(field_list:vearchpb.GetResponse.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// DeleteResponse

// .vearchpb.ResponseHead head = 1;
inline bool DeleteResponse::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool DeleteResponse::has_head() const {
  return _internal_has_head();
}
inline void DeleteResponse::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::vearchpb::ResponseHead& DeleteResponse::_internal_head() const {
  const ::vearchpb::ResponseHead* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::ResponseHead&>(
      ::vearchpb::_ResponseHead_default_instance_);
}
inline const ::vearchpb::ResponseHead& DeleteResponse::head() const {
  // @@protoc_insertion_point(field_get:vearchpb.DeleteResponse.head)
  return _internal_head();
}
inline void DeleteResponse::unsafe_arena_set_allocated_head(
    ::vearchpb::ResponseHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.DeleteResponse.head)
}
inline ::vearchpb::ResponseHead* DeleteResponse::release_head() {
  
  ::vearchpb::ResponseHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::ResponseHead* DeleteResponse::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:vearchpb.DeleteResponse.head)
  
  ::vearchpb::ResponseHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::vearchpb::ResponseHead* DeleteResponse::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::ResponseHead>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::vearchpb::ResponseHead* DeleteResponse::mutable_head() {
  ::vearchpb::ResponseHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:vearchpb.DeleteResponse.head)
  return _msg;
}
inline void DeleteResponse::set_allocated_head(::vearchpb::ResponseHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.DeleteResponse.head)
}

// repeated .vearchpb.Item items = 2;
inline int DeleteResponse::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int DeleteResponse::items_size() const {
  return _internal_items_size();
}
inline ::vearchpb::Item* DeleteResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.DeleteResponse.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Item >*
DeleteResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.DeleteResponse.items)
  return &_impl_.items_;
}
inline const ::vearchpb::Item& DeleteResponse::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::vearchpb::Item& DeleteResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.DeleteResponse.items)
  return _internal_items(index);
}
inline ::vearchpb::Item* DeleteResponse::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::vearchpb::Item* DeleteResponse::add_items() {
  ::vearchpb::Item* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:vearchpb.DeleteResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Item >&
DeleteResponse::items() const {
  // @@protoc_insertion_point(field_list:vearchpb.DeleteResponse.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// BulkResponse

// .vearchpb.ResponseHead head = 1;
inline bool BulkResponse::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool BulkResponse::has_head() const {
  return _internal_has_head();
}
inline void BulkResponse::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::vearchpb::ResponseHead& BulkResponse::_internal_head() const {
  const ::vearchpb::ResponseHead* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::ResponseHead&>(
      ::vearchpb::_ResponseHead_default_instance_);
}
inline const ::vearchpb::ResponseHead& BulkResponse::head() const {
  // @@protoc_insertion_point(field_get:vearchpb.BulkResponse.head)
  return _internal_head();
}
inline void BulkResponse::unsafe_arena_set_allocated_head(
    ::vearchpb::ResponseHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.BulkResponse.head)
}
inline ::vearchpb::ResponseHead* BulkResponse::release_head() {
  
  ::vearchpb::ResponseHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::ResponseHead* BulkResponse::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:vearchpb.BulkResponse.head)
  
  ::vearchpb::ResponseHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::vearchpb::ResponseHead* BulkResponse::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::ResponseHead>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::vearchpb::ResponseHead* BulkResponse::mutable_head() {
  ::vearchpb::ResponseHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:vearchpb.BulkResponse.head)
  return _msg;
}
inline void BulkResponse::set_allocated_head(::vearchpb::ResponseHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.BulkResponse.head)
}

// repeated .vearchpb.Item items = 2;
inline int BulkResponse::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int BulkResponse::items_size() const {
  return _internal_items_size();
}
inline ::vearchpb::Item* BulkResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.BulkResponse.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Item >*
BulkResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.BulkResponse.items)
  return &_impl_.items_;
}
inline const ::vearchpb::Item& BulkResponse::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::vearchpb::Item& BulkResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.BulkResponse.items)
  return _internal_items(index);
}
inline ::vearchpb::Item* BulkResponse::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::vearchpb::Item* BulkResponse::add_items() {
  ::vearchpb::Item* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:vearchpb.BulkResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Item >&
BulkResponse::items() const {
  // @@protoc_insertion_point(field_list:vearchpb.BulkResponse.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// ForceMergeResponse

// .vearchpb.ResponseHead head = 1;
inline bool ForceMergeResponse::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool ForceMergeResponse::has_head() const {
  return _internal_has_head();
}
inline void ForceMergeResponse::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::vearchpb::ResponseHead& ForceMergeResponse::_internal_head() const {
  const ::vearchpb::ResponseHead* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::ResponseHead&>(
      ::vearchpb::_ResponseHead_default_instance_);
}
inline const ::vearchpb::ResponseHead& ForceMergeResponse::head() const {
  // @@protoc_insertion_point(field_get:vearchpb.ForceMergeResponse.head)
  return _internal_head();
}
inline void ForceMergeResponse::unsafe_arena_set_allocated_head(
    ::vearchpb::ResponseHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.ForceMergeResponse.head)
}
inline ::vearchpb::ResponseHead* ForceMergeResponse::release_head() {
  
  ::vearchpb::ResponseHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::ResponseHead* ForceMergeResponse::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:vearchpb.ForceMergeResponse.head)
  
  ::vearchpb::ResponseHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::vearchpb::ResponseHead* ForceMergeResponse::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::ResponseHead>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::vearchpb::ResponseHead* ForceMergeResponse::mutable_head() {
  ::vearchpb::ResponseHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:vearchpb.ForceMergeResponse.head)
  return _msg;
}
inline void ForceMergeResponse::set_allocated_head(::vearchpb::ResponseHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.ForceMergeResponse.head)
}

// .vearchpb.SearchStatus shards = 2;
inline bool ForceMergeResponse::_internal_has_shards() const {
  return this != internal_default_instance() && _impl_.shards_ != nullptr;
}
inline bool ForceMergeResponse::has_shards() const {
  return _internal_has_shards();
}
inline void ForceMergeResponse::clear_shards() {
  if (GetArenaForAllocation() == nullptr && _impl_.shards_ != nullptr) {
    delete _impl_.shards_;
  }
  _impl_.shards_ = nullptr;
}
inline const ::vearchpb::SearchStatus& ForceMergeResponse::_internal_shards() const {
  const ::vearchpb::SearchStatus* p = _impl_.shards_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::SearchStatus&>(
      ::vearchpb::_SearchStatus_default_instance_);
}
inline const ::vearchpb::SearchStatus& ForceMergeResponse::shards() const {
  // @@protoc_insertion_point(field_get:vearchpb.ForceMergeResponse.shards)
  return _internal_shards();
}
inline void ForceMergeResponse::unsafe_arena_set_allocated_shards(
    ::vearchpb::SearchStatus* shards) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shards_);
  }
  _impl_.shards_ = shards;
  if (shards) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.ForceMergeResponse.shards)
}
inline ::vearchpb::SearchStatus* ForceMergeResponse::release_shards() {
  
  ::vearchpb::SearchStatus* temp = _impl_.shards_;
  _impl_.shards_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::SearchStatus* ForceMergeResponse::unsafe_arena_release_shards() {
  // @@protoc_insertion_point(field_release:vearchpb.ForceMergeResponse.shards)
  
  ::vearchpb::SearchStatus* temp = _impl_.shards_;
  _impl_.shards_ = nullptr;
  return temp;
}
inline ::vearchpb::SearchStatus* ForceMergeResponse::_internal_mutable_shards() {
  
  if (_impl_.shards_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::SearchStatus>(GetArenaForAllocation());
    _impl_.shards_ = p;
  }
  return _impl_.shards_;
}
inline ::vearchpb::SearchStatus* ForceMergeResponse::mutable_shards() {
  ::vearchpb::SearchStatus* _msg = _internal_mutable_shards();
  // @@protoc_insertion_point(field_mutable:vearchpb.ForceMergeResponse.shards)
  return _msg;
}
inline void ForceMergeResponse::set_allocated_shards(::vearchpb::SearchStatus* shards) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.shards_;
  }
  if (shards) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shards);
    if (message_arena != submessage_arena) {
      shards = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shards, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.shards_ = shards;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.ForceMergeResponse.shards)
}

// -------------------------------------------------------------------

// DelByQueryeResponse

// .vearchpb.ResponseHead head = 1;
inline bool DelByQueryeResponse::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool DelByQueryeResponse::has_head() const {
  return _internal_has_head();
}
inline void DelByQueryeResponse::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::vearchpb::ResponseHead& DelByQueryeResponse::_internal_head() const {
  const ::vearchpb::ResponseHead* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::ResponseHead&>(
      ::vearchpb::_ResponseHead_default_instance_);
}
inline const ::vearchpb::ResponseHead& DelByQueryeResponse::head() const {
  // @@protoc_insertion_point(field_get:vearchpb.DelByQueryeResponse.head)
  return _internal_head();
}
inline void DelByQueryeResponse::unsafe_arena_set_allocated_head(
    ::vearchpb::ResponseHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.DelByQueryeResponse.head)
}
inline ::vearchpb::ResponseHead* DelByQueryeResponse::release_head() {
  
  ::vearchpb::ResponseHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::ResponseHead* DelByQueryeResponse::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:vearchpb.DelByQueryeResponse.head)
  
  ::vearchpb::ResponseHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::vearchpb::ResponseHead* DelByQueryeResponse::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::ResponseHead>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::vearchpb::ResponseHead* DelByQueryeResponse::mutable_head() {
  ::vearchpb::ResponseHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:vearchpb.DelByQueryeResponse.head)
  return _msg;
}
inline void DelByQueryeResponse::set_allocated_head(::vearchpb::ResponseHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.DelByQueryeResponse.head)
}

// int32 DelNum = 2;
inline void DelByQueryeResponse::clear_delnum() {
  _impl_.delnum_ = 0;
}
inline int32_t DelByQueryeResponse::_internal_delnum() const {
  return _impl_.delnum_;
}
inline int32_t DelByQueryeResponse::delnum() const {
  // @@protoc_insertion_point(field_get:vearchpb.DelByQueryeResponse.DelNum)
  return _internal_delnum();
}
inline void DelByQueryeResponse::_internal_set_delnum(int32_t value) {
  
  _impl_.delnum_ = value;
}
inline void DelByQueryeResponse::set_delnum(int32_t value) {
  _internal_set_delnum(value);
  // @@protoc_insertion_point(field_set:vearchpb.DelByQueryeResponse.DelNum)
}

// repeated string ids_str = 3;
inline int DelByQueryeResponse::_internal_ids_str_size() const {
  return _impl_.ids_str_.size();
}
inline int DelByQueryeResponse::ids_str_size() const {
  return _internal_ids_str_size();
}
inline void DelByQueryeResponse::clear_ids_str() {
  _impl_.ids_str_.Clear();
}
inline std::string* DelByQueryeResponse::add_ids_str() {
  std::string* _s = _internal_add_ids_str();
  // @@protoc_insertion_point(field_add_mutable:vearchpb.DelByQueryeResponse.ids_str)
  return _s;
}
inline const std::string& DelByQueryeResponse::_internal_ids_str(int index) const {
  return _impl_.ids_str_.Get(index);
}
inline const std::string& DelByQueryeResponse::ids_str(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.DelByQueryeResponse.ids_str)
  return _internal_ids_str(index);
}
inline std::string* DelByQueryeResponse::mutable_ids_str(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.DelByQueryeResponse.ids_str)
  return _impl_.ids_str_.Mutable(index);
}
inline void DelByQueryeResponse::set_ids_str(int index, const std::string& value) {
  _impl_.ids_str_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:vearchpb.DelByQueryeResponse.ids_str)
}
inline void DelByQueryeResponse::set_ids_str(int index, std::string&& value) {
  _impl_.ids_str_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:vearchpb.DelByQueryeResponse.ids_str)
}
inline void DelByQueryeResponse::set_ids_str(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ids_str_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vearchpb.DelByQueryeResponse.ids_str)
}
inline void DelByQueryeResponse::set_ids_str(int index, const char* value, size_t size) {
  _impl_.ids_str_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vearchpb.DelByQueryeResponse.ids_str)
}
inline std::string* DelByQueryeResponse::_internal_add_ids_str() {
  return _impl_.ids_str_.Add();
}
inline void DelByQueryeResponse::add_ids_str(const std::string& value) {
  _impl_.ids_str_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vearchpb.DelByQueryeResponse.ids_str)
}
inline void DelByQueryeResponse::add_ids_str(std::string&& value) {
  _impl_.ids_str_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vearchpb.DelByQueryeResponse.ids_str)
}
inline void DelByQueryeResponse::add_ids_str(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ids_str_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vearchpb.DelByQueryeResponse.ids_str)
}
inline void DelByQueryeResponse::add_ids_str(const char* value, size_t size) {
  _impl_.ids_str_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vearchpb.DelByQueryeResponse.ids_str)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DelByQueryeResponse::ids_str() const {
  // @@protoc_insertion_point(field_list:vearchpb.DelByQueryeResponse.ids_str)
  return _impl_.ids_str_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DelByQueryeResponse::mutable_ids_str() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.DelByQueryeResponse.ids_str)
  return &_impl_.ids_str_;
}

// -------------------------------------------------------------------

// FlushResponse

// .vearchpb.ResponseHead head = 1;
inline bool FlushResponse::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool FlushResponse::has_head() const {
  return _internal_has_head();
}
inline void FlushResponse::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::vearchpb::ResponseHead& FlushResponse::_internal_head() const {
  const ::vearchpb::ResponseHead* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::ResponseHead&>(
      ::vearchpb::_ResponseHead_default_instance_);
}
inline const ::vearchpb::ResponseHead& FlushResponse::head() const {
  // @@protoc_insertion_point(field_get:vearchpb.FlushResponse.head)
  return _internal_head();
}
inline void FlushResponse::unsafe_arena_set_allocated_head(
    ::vearchpb::ResponseHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.FlushResponse.head)
}
inline ::vearchpb::ResponseHead* FlushResponse::release_head() {
  
  ::vearchpb::ResponseHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::ResponseHead* FlushResponse::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:vearchpb.FlushResponse.head)
  
  ::vearchpb::ResponseHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::vearchpb::ResponseHead* FlushResponse::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::ResponseHead>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::vearchpb::ResponseHead* FlushResponse::mutable_head() {
  ::vearchpb::ResponseHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:vearchpb.FlushResponse.head)
  return _msg;
}
inline void FlushResponse::set_allocated_head(::vearchpb::ResponseHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.FlushResponse.head)
}

// .vearchpb.SearchStatus shards = 2;
inline bool FlushResponse::_internal_has_shards() const {
  return this != internal_default_instance() && _impl_.shards_ != nullptr;
}
inline bool FlushResponse::has_shards() const {
  return _internal_has_shards();
}
inline void FlushResponse::clear_shards() {
  if (GetArenaForAllocation() == nullptr && _impl_.shards_ != nullptr) {
    delete _impl_.shards_;
  }
  _impl_.shards_ = nullptr;
}
inline const ::vearchpb::SearchStatus& FlushResponse::_internal_shards() const {
  const ::vearchpb::SearchStatus* p = _impl_.shards_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::SearchStatus&>(
      ::vearchpb::_SearchStatus_default_instance_);
}
inline const ::vearchpb::SearchStatus& FlushResponse::shards() const {
  // @@protoc_insertion_point(field_get:vearchpb.FlushResponse.shards)
  return _internal_shards();
}
inline void FlushResponse::unsafe_arena_set_allocated_shards(
    ::vearchpb::SearchStatus* shards) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shards_);
  }
  _impl_.shards_ = shards;
  if (shards) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.FlushResponse.shards)
}
inline ::vearchpb::SearchStatus* FlushResponse::release_shards() {
  
  ::vearchpb::SearchStatus* temp = _impl_.shards_;
  _impl_.shards_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::SearchStatus* FlushResponse::unsafe_arena_release_shards() {
  // @@protoc_insertion_point(field_release:vearchpb.FlushResponse.shards)
  
  ::vearchpb::SearchStatus* temp = _impl_.shards_;
  _impl_.shards_ = nullptr;
  return temp;
}
inline ::vearchpb::SearchStatus* FlushResponse::_internal_mutable_shards() {
  
  if (_impl_.shards_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::SearchStatus>(GetArenaForAllocation());
    _impl_.shards_ = p;
  }
  return _impl_.shards_;
}
inline ::vearchpb::SearchStatus* FlushResponse::mutable_shards() {
  ::vearchpb::SearchStatus* _msg = _internal_mutable_shards();
  // @@protoc_insertion_point(field_mutable:vearchpb.FlushResponse.shards)
  return _msg;
}
inline void FlushResponse::set_allocated_shards(::vearchpb::SearchStatus* shards) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.shards_;
  }
  if (shards) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shards);
    if (message_arena != submessage_arena) {
      shards = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shards, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.shards_ = shards;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.FlushResponse.shards)
}

// -------------------------------------------------------------------

// IndexResponse

// .vearchpb.ResponseHead head = 1;
inline bool IndexResponse::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool IndexResponse::has_head() const {
  return _internal_has_head();
}
inline void IndexResponse::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::vearchpb::ResponseHead& IndexResponse::_internal_head() const {
  const ::vearchpb::ResponseHead* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::ResponseHead&>(
      ::vearchpb::_ResponseHead_default_instance_);
}
inline const ::vearchpb::ResponseHead& IndexResponse::head() const {
  // @@protoc_insertion_point(field_get:vearchpb.IndexResponse.head)
  return _internal_head();
}
inline void IndexResponse::unsafe_arena_set_allocated_head(
    ::vearchpb::ResponseHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.IndexResponse.head)
}
inline ::vearchpb::ResponseHead* IndexResponse::release_head() {
  
  ::vearchpb::ResponseHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::ResponseHead* IndexResponse::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:vearchpb.IndexResponse.head)
  
  ::vearchpb::ResponseHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::vearchpb::ResponseHead* IndexResponse::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::ResponseHead>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::vearchpb::ResponseHead* IndexResponse::mutable_head() {
  ::vearchpb::ResponseHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:vearchpb.IndexResponse.head)
  return _msg;
}
inline void IndexResponse::set_allocated_head(::vearchpb::ResponseHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.IndexResponse.head)
}

// .vearchpb.SearchStatus shards = 2;
inline bool IndexResponse::_internal_has_shards() const {
  return this != internal_default_instance() && _impl_.shards_ != nullptr;
}
inline bool IndexResponse::has_shards() const {
  return _internal_has_shards();
}
inline void IndexResponse::clear_shards() {
  if (GetArenaForAllocation() == nullptr && _impl_.shards_ != nullptr) {
    delete _impl_.shards_;
  }
  _impl_.shards_ = nullptr;
}
inline const ::vearchpb::SearchStatus& IndexResponse::_internal_shards() const {
  const ::vearchpb::SearchStatus* p = _impl_.shards_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::SearchStatus&>(
      ::vearchpb::_SearchStatus_default_instance_);
}
inline const ::vearchpb::SearchStatus& IndexResponse::shards() const {
  // @@protoc_insertion_point(field_get:vearchpb.IndexResponse.shards)
  return _internal_shards();
}
inline void IndexResponse::unsafe_arena_set_allocated_shards(
    ::vearchpb::SearchStatus* shards) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shards_);
  }
  _impl_.shards_ = shards;
  if (shards) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.IndexResponse.shards)
}
inline ::vearchpb::SearchStatus* IndexResponse::release_shards() {
  
  ::vearchpb::SearchStatus* temp = _impl_.shards_;
  _impl_.shards_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::SearchStatus* IndexResponse::unsafe_arena_release_shards() {
  // @@protoc_insertion_point(field_release:vearchpb.IndexResponse.shards)
  
  ::vearchpb::SearchStatus* temp = _impl_.shards_;
  _impl_.shards_ = nullptr;
  return temp;
}
inline ::vearchpb::SearchStatus* IndexResponse::_internal_mutable_shards() {
  
  if (_impl_.shards_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::SearchStatus>(GetArenaForAllocation());
    _impl_.shards_ = p;
  }
  return _impl_.shards_;
}
inline ::vearchpb::SearchStatus* IndexResponse::mutable_shards() {
  ::vearchpb::SearchStatus* _msg = _internal_mutable_shards();
  // @@protoc_insertion_point(field_mutable:vearchpb.IndexResponse.shards)
  return _msg;
}
inline void IndexResponse::set_allocated_shards(::vearchpb::SearchStatus* shards) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.shards_;
  }
  if (shards) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shards);
    if (message_arena != submessage_arena) {
      shards = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shards, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.shards_ = shards;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.IndexResponse.shards)
}

// -------------------------------------------------------------------

// TermFilter

// string field = 1;
inline void TermFilter::clear_field() {
  _impl_.field_.ClearToEmpty();
}
inline const std::string& TermFilter::field() const {
  // @@protoc_insertion_point(field_get:vearchpb.TermFilter.field)
  return _internal_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TermFilter::set_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.TermFilter.field)
}
inline std::string* TermFilter::mutable_field() {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:vearchpb.TermFilter.field)
  return _s;
}
inline const std::string& TermFilter::_internal_field() const {
  return _impl_.field_.Get();
}
inline void TermFilter::_internal_set_field(const std::string& value) {
  
  _impl_.field_.Set(value, GetArenaForAllocation());
}
inline std::string* TermFilter::_internal_mutable_field() {
  
  return _impl_.field_.Mutable(GetArenaForAllocation());
}
inline std::string* TermFilter::release_field() {
  // @@protoc_insertion_point(field_release:vearchpb.TermFilter.field)
  return _impl_.field_.Release();
}
inline void TermFilter::set_allocated_field(std::string* field) {
  if (field != nullptr) {
    
  } else {
    
  }
  _impl_.field_.SetAllocated(field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field_.IsDefault()) {
    _impl_.field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.TermFilter.field)
}

// bytes value = 2;
inline void TermFilter::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& TermFilter::value() const {
  // @@protoc_insertion_point(field_get:vearchpb.TermFilter.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TermFilter::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.TermFilter.value)
}
inline std::string* TermFilter::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:vearchpb.TermFilter.value)
  return _s;
}
inline const std::string& TermFilter::_internal_value() const {
  return _impl_.value_.Get();
}
inline void TermFilter::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* TermFilter::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* TermFilter::release_value() {
  // @@protoc_insertion_point(field_release:vearchpb.TermFilter.value)
  return _impl_.value_.Release();
}
inline void TermFilter::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.TermFilter.value)
}

// int32 is_union = 3;
inline void TermFilter::clear_is_union() {
  _impl_.is_union_ = 0;
}
inline int32_t TermFilter::_internal_is_union() const {
  return _impl_.is_union_;
}
inline int32_t TermFilter::is_union() const {
  // @@protoc_insertion_point(field_get:vearchpb.TermFilter.is_union)
  return _internal_is_union();
}
inline void TermFilter::_internal_set_is_union(int32_t value) {
  
  _impl_.is_union_ = value;
}
inline void TermFilter::set_is_union(int32_t value) {
  _internal_set_is_union(value);
  // @@protoc_insertion_point(field_set:vearchpb.TermFilter.is_union)
}

// -------------------------------------------------------------------

// RangeFilter

// string field = 1;
inline void RangeFilter::clear_field() {
  _impl_.field_.ClearToEmpty();
}
inline const std::string& RangeFilter::field() const {
  // @@protoc_insertion_point(field_get:vearchpb.RangeFilter.field)
  return _internal_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangeFilter::set_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.RangeFilter.field)
}
inline std::string* RangeFilter::mutable_field() {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:vearchpb.RangeFilter.field)
  return _s;
}
inline const std::string& RangeFilter::_internal_field() const {
  return _impl_.field_.Get();
}
inline void RangeFilter::_internal_set_field(const std::string& value) {
  
  _impl_.field_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeFilter::_internal_mutable_field() {
  
  return _impl_.field_.Mutable(GetArenaForAllocation());
}
inline std::string* RangeFilter::release_field() {
  // @@protoc_insertion_point(field_release:vearchpb.RangeFilter.field)
  return _impl_.field_.Release();
}
inline void RangeFilter::set_allocated_field(std::string* field) {
  if (field != nullptr) {
    
  } else {
    
  }
  _impl_.field_.SetAllocated(field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field_.IsDefault()) {
    _impl_.field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.RangeFilter.field)
}

// bytes lower_value = 2;
inline void RangeFilter::clear_lower_value() {
  _impl_.lower_value_.ClearToEmpty();
}
inline const std::string& RangeFilter::lower_value() const {
  // @@protoc_insertion_point(field_get:vearchpb.RangeFilter.lower_value)
  return _internal_lower_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangeFilter::set_lower_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lower_value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.RangeFilter.lower_value)
}
inline std::string* RangeFilter::mutable_lower_value() {
  std::string* _s = _internal_mutable_lower_value();
  // @@protoc_insertion_point(field_mutable:vearchpb.RangeFilter.lower_value)
  return _s;
}
inline const std::string& RangeFilter::_internal_lower_value() const {
  return _impl_.lower_value_.Get();
}
inline void RangeFilter::_internal_set_lower_value(const std::string& value) {
  
  _impl_.lower_value_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeFilter::_internal_mutable_lower_value() {
  
  return _impl_.lower_value_.Mutable(GetArenaForAllocation());
}
inline std::string* RangeFilter::release_lower_value() {
  // @@protoc_insertion_point(field_release:vearchpb.RangeFilter.lower_value)
  return _impl_.lower_value_.Release();
}
inline void RangeFilter::set_allocated_lower_value(std::string* lower_value) {
  if (lower_value != nullptr) {
    
  } else {
    
  }
  _impl_.lower_value_.SetAllocated(lower_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lower_value_.IsDefault()) {
    _impl_.lower_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.RangeFilter.lower_value)
}

// bytes upper_value = 3;
inline void RangeFilter::clear_upper_value() {
  _impl_.upper_value_.ClearToEmpty();
}
inline const std::string& RangeFilter::upper_value() const {
  // @@protoc_insertion_point(field_get:vearchpb.RangeFilter.upper_value)
  return _internal_upper_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangeFilter::set_upper_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.upper_value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.RangeFilter.upper_value)
}
inline std::string* RangeFilter::mutable_upper_value() {
  std::string* _s = _internal_mutable_upper_value();
  // @@protoc_insertion_point(field_mutable:vearchpb.RangeFilter.upper_value)
  return _s;
}
inline const std::string& RangeFilter::_internal_upper_value() const {
  return _impl_.upper_value_.Get();
}
inline void RangeFilter::_internal_set_upper_value(const std::string& value) {
  
  _impl_.upper_value_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeFilter::_internal_mutable_upper_value() {
  
  return _impl_.upper_value_.Mutable(GetArenaForAllocation());
}
inline std::string* RangeFilter::release_upper_value() {
  // @@protoc_insertion_point(field_release:vearchpb.RangeFilter.upper_value)
  return _impl_.upper_value_.Release();
}
inline void RangeFilter::set_allocated_upper_value(std::string* upper_value) {
  if (upper_value != nullptr) {
    
  } else {
    
  }
  _impl_.upper_value_.SetAllocated(upper_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.upper_value_.IsDefault()) {
    _impl_.upper_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.RangeFilter.upper_value)
}

// bool include_lower = 4;
inline void RangeFilter::clear_include_lower() {
  _impl_.include_lower_ = false;
}
inline bool RangeFilter::_internal_include_lower() const {
  return _impl_.include_lower_;
}
inline bool RangeFilter::include_lower() const {
  // @@protoc_insertion_point(field_get:vearchpb.RangeFilter.include_lower)
  return _internal_include_lower();
}
inline void RangeFilter::_internal_set_include_lower(bool value) {
  
  _impl_.include_lower_ = value;
}
inline void RangeFilter::set_include_lower(bool value) {
  _internal_set_include_lower(value);
  // @@protoc_insertion_point(field_set:vearchpb.RangeFilter.include_lower)
}

// bool include_upper = 5;
inline void RangeFilter::clear_include_upper() {
  _impl_.include_upper_ = false;
}
inline bool RangeFilter::_internal_include_upper() const {
  return _impl_.include_upper_;
}
inline bool RangeFilter::include_upper() const {
  // @@protoc_insertion_point(field_get:vearchpb.RangeFilter.include_upper)
  return _internal_include_upper();
}
inline void RangeFilter::_internal_set_include_upper(bool value) {
  
  _impl_.include_upper_ = value;
}
inline void RangeFilter::set_include_upper(bool value) {
  _internal_set_include_upper(value);
  // @@protoc_insertion_point(field_set:vearchpb.RangeFilter.include_upper)
}

// int32 is_union = 6;
inline void RangeFilter::clear_is_union() {
  _impl_.is_union_ = 0;
}
inline int32_t RangeFilter::_internal_is_union() const {
  return _impl_.is_union_;
}
inline int32_t RangeFilter::is_union() const {
  // @@protoc_insertion_point(field_get:vearchpb.RangeFilter.is_union)
  return _internal_is_union();
}
inline void RangeFilter::_internal_set_is_union(int32_t value) {
  
  _impl_.is_union_ = value;
}
inline void RangeFilter::set_is_union(int32_t value) {
  _internal_set_is_union(value);
  // @@protoc_insertion_point(field_set:vearchpb.RangeFilter.is_union)
}

// -------------------------------------------------------------------

// SortField

// string field = 1;
inline void SortField::clear_field() {
  _impl_.field_.ClearToEmpty();
}
inline const std::string& SortField::field() const {
  // @@protoc_insertion_point(field_get:vearchpb.SortField.field)
  return _internal_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SortField::set_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.SortField.field)
}
inline std::string* SortField::mutable_field() {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:vearchpb.SortField.field)
  return _s;
}
inline const std::string& SortField::_internal_field() const {
  return _impl_.field_.Get();
}
inline void SortField::_internal_set_field(const std::string& value) {
  
  _impl_.field_.Set(value, GetArenaForAllocation());
}
inline std::string* SortField::_internal_mutable_field() {
  
  return _impl_.field_.Mutable(GetArenaForAllocation());
}
inline std::string* SortField::release_field() {
  // @@protoc_insertion_point(field_release:vearchpb.SortField.field)
  return _impl_.field_.Release();
}
inline void SortField::set_allocated_field(std::string* field) {
  if (field != nullptr) {
    
  } else {
    
  }
  _impl_.field_.SetAllocated(field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field_.IsDefault()) {
    _impl_.field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.SortField.field)
}

// bool type = 2;
inline void SortField::clear_type() {
  _impl_.type_ = false;
}
inline bool SortField::_internal_type() const {
  return _impl_.type_;
}
inline bool SortField::type() const {
  // @@protoc_insertion_point(field_get:vearchpb.SortField.type)
  return _internal_type();
}
inline void SortField::_internal_set_type(bool value) {
  
  _impl_.type_ = value;
}
inline void SortField::set_type(bool value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:vearchpb.SortField.type)
}

// -------------------------------------------------------------------

// VectorQuery

// string name = 1;
inline void VectorQuery::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& VectorQuery::name() const {
  // @@protoc_insertion_point(field_get:vearchpb.VectorQuery.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VectorQuery::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.VectorQuery.name)
}
inline std::string* VectorQuery::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vearchpb.VectorQuery.name)
  return _s;
}
inline const std::string& VectorQuery::_internal_name() const {
  return _impl_.name_.Get();
}
inline void VectorQuery::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* VectorQuery::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* VectorQuery::release_name() {
  // @@protoc_insertion_point(field_release:vearchpb.VectorQuery.name)
  return _impl_.name_.Release();
}
inline void VectorQuery::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.VectorQuery.name)
}

// bytes value = 2;
inline void VectorQuery::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& VectorQuery::value() const {
  // @@protoc_insertion_point(field_get:vearchpb.VectorQuery.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VectorQuery::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.VectorQuery.value)
}
inline std::string* VectorQuery::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:vearchpb.VectorQuery.value)
  return _s;
}
inline const std::string& VectorQuery::_internal_value() const {
  return _impl_.value_.Get();
}
inline void VectorQuery::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* VectorQuery::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* VectorQuery::release_value() {
  // @@protoc_insertion_point(field_release:vearchpb.VectorQuery.value)
  return _impl_.value_.Release();
}
inline void VectorQuery::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.VectorQuery.value)
}

// double min_score = 3;
inline void VectorQuery::clear_min_score() {
  _impl_.min_score_ = 0;
}
inline double VectorQuery::_internal_min_score() const {
  return _impl_.min_score_;
}
inline double VectorQuery::min_score() const {
  // @@protoc_insertion_point(field_get:vearchpb.VectorQuery.min_score)
  return _internal_min_score();
}
inline void VectorQuery::_internal_set_min_score(double value) {
  
  _impl_.min_score_ = value;
}
inline void VectorQuery::set_min_score(double value) {
  _internal_set_min_score(value);
  // @@protoc_insertion_point(field_set:vearchpb.VectorQuery.min_score)
}

// double max_score = 4;
inline void VectorQuery::clear_max_score() {
  _impl_.max_score_ = 0;
}
inline double VectorQuery::_internal_max_score() const {
  return _impl_.max_score_;
}
inline double VectorQuery::max_score() const {
  // @@protoc_insertion_point(field_get:vearchpb.VectorQuery.max_score)
  return _internal_max_score();
}
inline void VectorQuery::_internal_set_max_score(double value) {
  
  _impl_.max_score_ = value;
}
inline void VectorQuery::set_max_score(double value) {
  _internal_set_max_score(value);
  // @@protoc_insertion_point(field_set:vearchpb.VectorQuery.max_score)
}

// string format = 5;
inline void VectorQuery::clear_format() {
  _impl_.format_.ClearToEmpty();
}
inline const std::string& VectorQuery::format() const {
  // @@protoc_insertion_point(field_get:vearchpb.VectorQuery.format)
  return _internal_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VectorQuery::set_format(ArgT0&& arg0, ArgT... args) {
 
 _impl_.format_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.VectorQuery.format)
}
inline std::string* VectorQuery::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:vearchpb.VectorQuery.format)
  return _s;
}
inline const std::string& VectorQuery::_internal_format() const {
  return _impl_.format_.Get();
}
inline void VectorQuery::_internal_set_format(const std::string& value) {
  
  _impl_.format_.Set(value, GetArenaForAllocation());
}
inline std::string* VectorQuery::_internal_mutable_format() {
  
  return _impl_.format_.Mutable(GetArenaForAllocation());
}
inline std::string* VectorQuery::release_format() {
  // @@protoc_insertion_point(field_release:vearchpb.VectorQuery.format)
  return _impl_.format_.Release();
}
inline void VectorQuery::set_allocated_format(std::string* format) {
  if (format != nullptr) {
    
  } else {
    
  }
  _impl_.format_.SetAllocated(format, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.format_.IsDefault()) {
    _impl_.format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.VectorQuery.format)
}

// string index_type = 6;
inline void VectorQuery::clear_index_type() {
  _impl_.index_type_.ClearToEmpty();
}
inline const std::string& VectorQuery::index_type() const {
  // @@protoc_insertion_point(field_get:vearchpb.VectorQuery.index_type)
  return _internal_index_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VectorQuery::set_index_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.index_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.VectorQuery.index_type)
}
inline std::string* VectorQuery::mutable_index_type() {
  std::string* _s = _internal_mutable_index_type();
  // @@protoc_insertion_point(field_mutable:vearchpb.VectorQuery.index_type)
  return _s;
}
inline const std::string& VectorQuery::_internal_index_type() const {
  return _impl_.index_type_.Get();
}
inline void VectorQuery::_internal_set_index_type(const std::string& value) {
  
  _impl_.index_type_.Set(value, GetArenaForAllocation());
}
inline std::string* VectorQuery::_internal_mutable_index_type() {
  
  return _impl_.index_type_.Mutable(GetArenaForAllocation());
}
inline std::string* VectorQuery::release_index_type() {
  // @@protoc_insertion_point(field_release:vearchpb.VectorQuery.index_type)
  return _impl_.index_type_.Release();
}
inline void VectorQuery::set_allocated_index_type(std::string* index_type) {
  if (index_type != nullptr) {
    
  } else {
    
  }
  _impl_.index_type_.SetAllocated(index_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.index_type_.IsDefault()) {
    _impl_.index_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.VectorQuery.index_type)
}

// -------------------------------------------------------------------

// IndexParameters

// .vearchpb.IndexParameters.DistanceMetricType metric_type = 1;
inline void IndexParameters::clear_metric_type() {
  _impl_.metric_type_ = 0;
}
inline ::vearchpb::IndexParameters_DistanceMetricType IndexParameters::_internal_metric_type() const {
  return static_cast< ::vearchpb::IndexParameters_DistanceMetricType >(_impl_.metric_type_);
}
inline ::vearchpb::IndexParameters_DistanceMetricType IndexParameters::metric_type() const {
  // @@protoc_insertion_point(field_get:vearchpb.IndexParameters.metric_type)
  return _internal_metric_type();
}
inline void IndexParameters::_internal_set_metric_type(::vearchpb::IndexParameters_DistanceMetricType value) {
  
  _impl_.metric_type_ = value;
}
inline void IndexParameters::set_metric_type(::vearchpb::IndexParameters_DistanceMetricType value) {
  _internal_set_metric_type(value);
  // @@protoc_insertion_point(field_set:vearchpb.IndexParameters.metric_type)
}

// int32 nprobe = 2;
inline void IndexParameters::clear_nprobe() {
  _impl_.nprobe_ = 0;
}
inline int32_t IndexParameters::_internal_nprobe() const {
  return _impl_.nprobe_;
}
inline int32_t IndexParameters::nprobe() const {
  // @@protoc_insertion_point(field_get:vearchpb.IndexParameters.nprobe)
  return _internal_nprobe();
}
inline void IndexParameters::_internal_set_nprobe(int32_t value) {
  
  _impl_.nprobe_ = value;
}
inline void IndexParameters::set_nprobe(int32_t value) {
  _internal_set_nprobe(value);
  // @@protoc_insertion_point(field_set:vearchpb.IndexParameters.nprobe)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// QueryRequest

// .vearchpb.RequestHead head = 1;
inline bool QueryRequest::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool QueryRequest::has_head() const {
  return _internal_has_head();
}
inline void QueryRequest::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::vearchpb::RequestHead& QueryRequest::_internal_head() const {
  const ::vearchpb::RequestHead* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::RequestHead&>(
      ::vearchpb::_RequestHead_default_instance_);
}
inline const ::vearchpb::RequestHead& QueryRequest::head() const {
  // @@protoc_insertion_point(field_get:vearchpb.QueryRequest.head)
  return _internal_head();
}
inline void QueryRequest::unsafe_arena_set_allocated_head(
    ::vearchpb::RequestHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.QueryRequest.head)
}
inline ::vearchpb::RequestHead* QueryRequest::release_head() {
  
  ::vearchpb::RequestHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::RequestHead* QueryRequest::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:vearchpb.QueryRequest.head)
  
  ::vearchpb::RequestHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::vearchpb::RequestHead* QueryRequest::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::RequestHead>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::vearchpb::RequestHead* QueryRequest::mutable_head() {
  ::vearchpb::RequestHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:vearchpb.QueryRequest.head)
  return _msg;
}
inline void QueryRequest::set_allocated_head(::vearchpb::RequestHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.QueryRequest.head)
}

// repeated string document_ids = 2;
inline int QueryRequest::_internal_document_ids_size() const {
  return _impl_.document_ids_.size();
}
inline int QueryRequest::document_ids_size() const {
  return _internal_document_ids_size();
}
inline void QueryRequest::clear_document_ids() {
  _impl_.document_ids_.Clear();
}
inline std::string* QueryRequest::add_document_ids() {
  std::string* _s = _internal_add_document_ids();
  // @@protoc_insertion_point(field_add_mutable:vearchpb.QueryRequest.document_ids)
  return _s;
}
inline const std::string& QueryRequest::_internal_document_ids(int index) const {
  return _impl_.document_ids_.Get(index);
}
inline const std::string& QueryRequest::document_ids(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.QueryRequest.document_ids)
  return _internal_document_ids(index);
}
inline std::string* QueryRequest::mutable_document_ids(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.QueryRequest.document_ids)
  return _impl_.document_ids_.Mutable(index);
}
inline void QueryRequest::set_document_ids(int index, const std::string& value) {
  _impl_.document_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:vearchpb.QueryRequest.document_ids)
}
inline void QueryRequest::set_document_ids(int index, std::string&& value) {
  _impl_.document_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:vearchpb.QueryRequest.document_ids)
}
inline void QueryRequest::set_document_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.document_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vearchpb.QueryRequest.document_ids)
}
inline void QueryRequest::set_document_ids(int index, const char* value, size_t size) {
  _impl_.document_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vearchpb.QueryRequest.document_ids)
}
inline std::string* QueryRequest::_internal_add_document_ids() {
  return _impl_.document_ids_.Add();
}
inline void QueryRequest::add_document_ids(const std::string& value) {
  _impl_.document_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vearchpb.QueryRequest.document_ids)
}
inline void QueryRequest::add_document_ids(std::string&& value) {
  _impl_.document_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vearchpb.QueryRequest.document_ids)
}
inline void QueryRequest::add_document_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.document_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vearchpb.QueryRequest.document_ids)
}
inline void QueryRequest::add_document_ids(const char* value, size_t size) {
  _impl_.document_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vearchpb.QueryRequest.document_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryRequest::document_ids() const {
  // @@protoc_insertion_point(field_list:vearchpb.QueryRequest.document_ids)
  return _impl_.document_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryRequest::mutable_document_ids() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.QueryRequest.document_ids)
  return &_impl_.document_ids_;
}

// int32 partition_id = 3;
inline void QueryRequest::clear_partition_id() {
  _impl_.partition_id_ = 0;
}
inline int32_t QueryRequest::_internal_partition_id() const {
  return _impl_.partition_id_;
}
inline int32_t QueryRequest::partition_id() const {
  // @@protoc_insertion_point(field_get:vearchpb.QueryRequest.partition_id)
  return _internal_partition_id();
}
inline void QueryRequest::_internal_set_partition_id(int32_t value) {
  
  _impl_.partition_id_ = value;
}
inline void QueryRequest::set_partition_id(int32_t value) {
  _internal_set_partition_id(value);
  // @@protoc_insertion_point(field_set:vearchpb.QueryRequest.partition_id)
}

// bool next = 4;
inline void QueryRequest::clear_next() {
  _impl_.next_ = false;
}
inline bool QueryRequest::_internal_next() const {
  return _impl_.next_;
}
inline bool QueryRequest::next() const {
  // @@protoc_insertion_point(field_get:vearchpb.QueryRequest.next)
  return _internal_next();
}
inline void QueryRequest::_internal_set_next(bool value) {
  
  _impl_.next_ = value;
}
inline void QueryRequest::set_next(bool value) {
  _internal_set_next(value);
  // @@protoc_insertion_point(field_set:vearchpb.QueryRequest.next)
}

// repeated .vearchpb.RangeFilter range_filters = 5;
inline int QueryRequest::_internal_range_filters_size() const {
  return _impl_.range_filters_.size();
}
inline int QueryRequest::range_filters_size() const {
  return _internal_range_filters_size();
}
inline void QueryRequest::clear_range_filters() {
  _impl_.range_filters_.Clear();
}
inline ::vearchpb::RangeFilter* QueryRequest::mutable_range_filters(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.QueryRequest.range_filters)
  return _impl_.range_filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::RangeFilter >*
QueryRequest::mutable_range_filters() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.QueryRequest.range_filters)
  return &_impl_.range_filters_;
}
inline const ::vearchpb::RangeFilter& QueryRequest::_internal_range_filters(int index) const {
  return _impl_.range_filters_.Get(index);
}
inline const ::vearchpb::RangeFilter& QueryRequest::range_filters(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.QueryRequest.range_filters)
  return _internal_range_filters(index);
}
inline ::vearchpb::RangeFilter* QueryRequest::_internal_add_range_filters() {
  return _impl_.range_filters_.Add();
}
inline ::vearchpb::RangeFilter* QueryRequest::add_range_filters() {
  ::vearchpb::RangeFilter* _add = _internal_add_range_filters();
  // @@protoc_insertion_point(field_add:vearchpb.QueryRequest.range_filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::RangeFilter >&
QueryRequest::range_filters() const {
  // @@protoc_insertion_point(field_list:vearchpb.QueryRequest.range_filters)
  return _impl_.range_filters_;
}

// repeated .vearchpb.TermFilter term_filters = 6;
inline int QueryRequest::_internal_term_filters_size() const {
  return _impl_.term_filters_.size();
}
inline int QueryRequest::term_filters_size() const {
  return _internal_term_filters_size();
}
inline void QueryRequest::clear_term_filters() {
  _impl_.term_filters_.Clear();
}
inline ::vearchpb::TermFilter* QueryRequest::mutable_term_filters(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.QueryRequest.term_filters)
  return _impl_.term_filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::TermFilter >*
QueryRequest::mutable_term_filters() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.QueryRequest.term_filters)
  return &_impl_.term_filters_;
}
inline const ::vearchpb::TermFilter& QueryRequest::_internal_term_filters(int index) const {
  return _impl_.term_filters_.Get(index);
}
inline const ::vearchpb::TermFilter& QueryRequest::term_filters(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.QueryRequest.term_filters)
  return _internal_term_filters(index);
}
inline ::vearchpb::TermFilter* QueryRequest::_internal_add_term_filters() {
  return _impl_.term_filters_.Add();
}
inline ::vearchpb::TermFilter* QueryRequest::add_term_filters() {
  ::vearchpb::TermFilter* _add = _internal_add_term_filters();
  // @@protoc_insertion_point(field_add:vearchpb.QueryRequest.term_filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::TermFilter >&
QueryRequest::term_filters() const {
  // @@protoc_insertion_point(field_list:vearchpb.QueryRequest.term_filters)
  return _impl_.term_filters_;
}

// repeated string fields = 7;
inline int QueryRequest::_internal_fields_size() const {
  return _impl_.fields_.size();
}
inline int QueryRequest::fields_size() const {
  return _internal_fields_size();
}
inline void QueryRequest::clear_fields() {
  _impl_.fields_.Clear();
}
inline std::string* QueryRequest::add_fields() {
  std::string* _s = _internal_add_fields();
  // @@protoc_insertion_point(field_add_mutable:vearchpb.QueryRequest.fields)
  return _s;
}
inline const std::string& QueryRequest::_internal_fields(int index) const {
  return _impl_.fields_.Get(index);
}
inline const std::string& QueryRequest::fields(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.QueryRequest.fields)
  return _internal_fields(index);
}
inline std::string* QueryRequest::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.QueryRequest.fields)
  return _impl_.fields_.Mutable(index);
}
inline void QueryRequest::set_fields(int index, const std::string& value) {
  _impl_.fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:vearchpb.QueryRequest.fields)
}
inline void QueryRequest::set_fields(int index, std::string&& value) {
  _impl_.fields_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:vearchpb.QueryRequest.fields)
}
inline void QueryRequest::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vearchpb.QueryRequest.fields)
}
inline void QueryRequest::set_fields(int index, const char* value, size_t size) {
  _impl_.fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vearchpb.QueryRequest.fields)
}
inline std::string* QueryRequest::_internal_add_fields() {
  return _impl_.fields_.Add();
}
inline void QueryRequest::add_fields(const std::string& value) {
  _impl_.fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vearchpb.QueryRequest.fields)
}
inline void QueryRequest::add_fields(std::string&& value) {
  _impl_.fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vearchpb.QueryRequest.fields)
}
inline void QueryRequest::add_fields(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vearchpb.QueryRequest.fields)
}
inline void QueryRequest::add_fields(const char* value, size_t size) {
  _impl_.fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vearchpb.QueryRequest.fields)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryRequest::fields() const {
  // @@protoc_insertion_point(field_list:vearchpb.QueryRequest.fields)
  return _impl_.fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryRequest::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.QueryRequest.fields)
  return &_impl_.fields_;
}

// bool is_vector_value = 8;
inline void QueryRequest::clear_is_vector_value() {
  _impl_.is_vector_value_ = false;
}
inline bool QueryRequest::_internal_is_vector_value() const {
  return _impl_.is_vector_value_;
}
inline bool QueryRequest::is_vector_value() const {
  // @@protoc_insertion_point(field_get:vearchpb.QueryRequest.is_vector_value)
  return _internal_is_vector_value();
}
inline void QueryRequest::_internal_set_is_vector_value(bool value) {
  
  _impl_.is_vector_value_ = value;
}
inline void QueryRequest::set_is_vector_value(bool value) {
  _internal_set_is_vector_value(value);
  // @@protoc_insertion_point(field_set:vearchpb.QueryRequest.is_vector_value)
}

// int32 limit = 9;
inline void QueryRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline int32_t QueryRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline int32_t QueryRequest::limit() const {
  // @@protoc_insertion_point(field_get:vearchpb.QueryRequest.limit)
  return _internal_limit();
}
inline void QueryRequest::_internal_set_limit(int32_t value) {
  
  _impl_.limit_ = value;
}
inline void QueryRequest::set_limit(int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:vearchpb.QueryRequest.limit)
}

// int32 page_size = 10;
inline void QueryRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t QueryRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t QueryRequest::page_size() const {
  // @@protoc_insertion_point(field_get:vearchpb.QueryRequest.page_size)
  return _internal_page_size();
}
inline void QueryRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void QueryRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:vearchpb.QueryRequest.page_size)
}

// string load_balance = 11;
inline void QueryRequest::clear_load_balance() {
  _impl_.load_balance_.ClearToEmpty();
}
inline const std::string& QueryRequest::load_balance() const {
  // @@protoc_insertion_point(field_get:vearchpb.QueryRequest.load_balance)
  return _internal_load_balance();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRequest::set_load_balance(ArgT0&& arg0, ArgT... args) {
 
 _impl_.load_balance_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.QueryRequest.load_balance)
}
inline std::string* QueryRequest::mutable_load_balance() {
  std::string* _s = _internal_mutable_load_balance();
  // @@protoc_insertion_point(field_mutable:vearchpb.QueryRequest.load_balance)
  return _s;
}
inline const std::string& QueryRequest::_internal_load_balance() const {
  return _impl_.load_balance_.Get();
}
inline void QueryRequest::_internal_set_load_balance(const std::string& value) {
  
  _impl_.load_balance_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryRequest::_internal_mutable_load_balance() {
  
  return _impl_.load_balance_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryRequest::release_load_balance() {
  // @@protoc_insertion_point(field_release:vearchpb.QueryRequest.load_balance)
  return _impl_.load_balance_.Release();
}
inline void QueryRequest::set_allocated_load_balance(std::string* load_balance) {
  if (load_balance != nullptr) {
    
  } else {
    
  }
  _impl_.load_balance_.SetAllocated(load_balance, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.load_balance_.IsDefault()) {
    _impl_.load_balance_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.QueryRequest.load_balance)
}

// map<string, string> sort_field_map = 12;
inline int QueryRequest::_internal_sort_field_map_size() const {
  return _impl_.sort_field_map_.size();
}
inline int QueryRequest::sort_field_map_size() const {
  return _internal_sort_field_map_size();
}
inline void QueryRequest::clear_sort_field_map() {
  _impl_.sort_field_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
QueryRequest::_internal_sort_field_map() const {
  return _impl_.sort_field_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
QueryRequest::sort_field_map() const {
  // @@protoc_insertion_point(field_map:vearchpb.QueryRequest.sort_field_map)
  return _internal_sort_field_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
QueryRequest::_internal_mutable_sort_field_map() {
  return _impl_.sort_field_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
QueryRequest::mutable_sort_field_map() {
  // @@protoc_insertion_point(field_mutable_map:vearchpb.QueryRequest.sort_field_map)
  return _internal_mutable_sort_field_map();
}

// repeated .vearchpb.SortField sort_fields = 13;
inline int QueryRequest::_internal_sort_fields_size() const {
  return _impl_.sort_fields_.size();
}
inline int QueryRequest::sort_fields_size() const {
  return _internal_sort_fields_size();
}
inline void QueryRequest::clear_sort_fields() {
  _impl_.sort_fields_.Clear();
}
inline ::vearchpb::SortField* QueryRequest::mutable_sort_fields(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.QueryRequest.sort_fields)
  return _impl_.sort_fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::SortField >*
QueryRequest::mutable_sort_fields() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.QueryRequest.sort_fields)
  return &_impl_.sort_fields_;
}
inline const ::vearchpb::SortField& QueryRequest::_internal_sort_fields(int index) const {
  return _impl_.sort_fields_.Get(index);
}
inline const ::vearchpb::SortField& QueryRequest::sort_fields(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.QueryRequest.sort_fields)
  return _internal_sort_fields(index);
}
inline ::vearchpb::SortField* QueryRequest::_internal_add_sort_fields() {
  return _impl_.sort_fields_.Add();
}
inline ::vearchpb::SortField* QueryRequest::add_sort_fields() {
  ::vearchpb::SortField* _add = _internal_add_sort_fields();
  // @@protoc_insertion_point(field_add:vearchpb.QueryRequest.sort_fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::SortField >&
QueryRequest::sort_fields() const {
  // @@protoc_insertion_point(field_list:vearchpb.QueryRequest.sort_fields)
  return _impl_.sort_fields_;
}

// bool trace = 14;
inline void QueryRequest::clear_trace() {
  _impl_.trace_ = false;
}
inline bool QueryRequest::_internal_trace() const {
  return _impl_.trace_;
}
inline bool QueryRequest::trace() const {
  // @@protoc_insertion_point(field_get:vearchpb.QueryRequest.trace)
  return _internal_trace();
}
inline void QueryRequest::_internal_set_trace(bool value) {
  
  _impl_.trace_ = value;
}
inline void QueryRequest::set_trace(bool value) {
  _internal_set_trace(value);
  // @@protoc_insertion_point(field_set:vearchpb.QueryRequest.trace)
}

// int32 operator = 15;
inline void QueryRequest::clear_operator_() {
  _impl_.operator__ = 0;
}
inline int32_t QueryRequest::_internal_operator_() const {
  return _impl_.operator__;
}
inline int32_t QueryRequest::operator_() const {
  // @@protoc_insertion_point(field_get:vearchpb.QueryRequest.operator)
  return _internal_operator_();
}
inline void QueryRequest::_internal_set_operator_(int32_t value) {
  
  _impl_.operator__ = value;
}
inline void QueryRequest::set_operator_(int32_t value) {
  _internal_set_operator_(value);
  // @@protoc_insertion_point(field_set:vearchpb.QueryRequest.operator)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SearchRequest

// .vearchpb.RequestHead head = 1;
inline bool SearchRequest::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool SearchRequest::has_head() const {
  return _internal_has_head();
}
inline void SearchRequest::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::vearchpb::RequestHead& SearchRequest::_internal_head() const {
  const ::vearchpb::RequestHead* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::RequestHead&>(
      ::vearchpb::_RequestHead_default_instance_);
}
inline const ::vearchpb::RequestHead& SearchRequest::head() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchRequest.head)
  return _internal_head();
}
inline void SearchRequest::unsafe_arena_set_allocated_head(
    ::vearchpb::RequestHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.SearchRequest.head)
}
inline ::vearchpb::RequestHead* SearchRequest::release_head() {
  
  ::vearchpb::RequestHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::RequestHead* SearchRequest::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:vearchpb.SearchRequest.head)
  
  ::vearchpb::RequestHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::vearchpb::RequestHead* SearchRequest::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::RequestHead>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::vearchpb::RequestHead* SearchRequest::mutable_head() {
  ::vearchpb::RequestHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:vearchpb.SearchRequest.head)
  return _msg;
}
inline void SearchRequest::set_allocated_head(::vearchpb::RequestHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.SearchRequest.head)
}

// int32 req_num = 2;
inline void SearchRequest::clear_req_num() {
  _impl_.req_num_ = 0;
}
inline int32_t SearchRequest::_internal_req_num() const {
  return _impl_.req_num_;
}
inline int32_t SearchRequest::req_num() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchRequest.req_num)
  return _internal_req_num();
}
inline void SearchRequest::_internal_set_req_num(int32_t value) {
  
  _impl_.req_num_ = value;
}
inline void SearchRequest::set_req_num(int32_t value) {
  _internal_set_req_num(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchRequest.req_num)
}

// int32 topN = 3;
inline void SearchRequest::clear_topn() {
  _impl_.topn_ = 0;
}
inline int32_t SearchRequest::_internal_topn() const {
  return _impl_.topn_;
}
inline int32_t SearchRequest::topn() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchRequest.topN)
  return _internal_topn();
}
inline void SearchRequest::_internal_set_topn(int32_t value) {
  
  _impl_.topn_ = value;
}
inline void SearchRequest::set_topn(int32_t value) {
  _internal_set_topn(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchRequest.topN)
}

// int32 is_brute_search = 4;
inline void SearchRequest::clear_is_brute_search() {
  _impl_.is_brute_search_ = 0;
}
inline int32_t SearchRequest::_internal_is_brute_search() const {
  return _impl_.is_brute_search_;
}
inline int32_t SearchRequest::is_brute_search() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchRequest.is_brute_search)
  return _internal_is_brute_search();
}
inline void SearchRequest::_internal_set_is_brute_search(int32_t value) {
  
  _impl_.is_brute_search_ = value;
}
inline void SearchRequest::set_is_brute_search(int32_t value) {
  _internal_set_is_brute_search(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchRequest.is_brute_search)
}

// repeated .vearchpb.VectorQuery vec_fields = 5;
inline int SearchRequest::_internal_vec_fields_size() const {
  return _impl_.vec_fields_.size();
}
inline int SearchRequest::vec_fields_size() const {
  return _internal_vec_fields_size();
}
inline void SearchRequest::clear_vec_fields() {
  _impl_.vec_fields_.Clear();
}
inline ::vearchpb::VectorQuery* SearchRequest::mutable_vec_fields(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.SearchRequest.vec_fields)
  return _impl_.vec_fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::VectorQuery >*
SearchRequest::mutable_vec_fields() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.SearchRequest.vec_fields)
  return &_impl_.vec_fields_;
}
inline const ::vearchpb::VectorQuery& SearchRequest::_internal_vec_fields(int index) const {
  return _impl_.vec_fields_.Get(index);
}
inline const ::vearchpb::VectorQuery& SearchRequest::vec_fields(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchRequest.vec_fields)
  return _internal_vec_fields(index);
}
inline ::vearchpb::VectorQuery* SearchRequest::_internal_add_vec_fields() {
  return _impl_.vec_fields_.Add();
}
inline ::vearchpb::VectorQuery* SearchRequest::add_vec_fields() {
  ::vearchpb::VectorQuery* _add = _internal_add_vec_fields();
  // @@protoc_insertion_point(field_add:vearchpb.SearchRequest.vec_fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::VectorQuery >&
SearchRequest::vec_fields() const {
  // @@protoc_insertion_point(field_list:vearchpb.SearchRequest.vec_fields)
  return _impl_.vec_fields_;
}

// repeated string fields = 6;
inline int SearchRequest::_internal_fields_size() const {
  return _impl_.fields_.size();
}
inline int SearchRequest::fields_size() const {
  return _internal_fields_size();
}
inline void SearchRequest::clear_fields() {
  _impl_.fields_.Clear();
}
inline std::string* SearchRequest::add_fields() {
  std::string* _s = _internal_add_fields();
  // @@protoc_insertion_point(field_add_mutable:vearchpb.SearchRequest.fields)
  return _s;
}
inline const std::string& SearchRequest::_internal_fields(int index) const {
  return _impl_.fields_.Get(index);
}
inline const std::string& SearchRequest::fields(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchRequest.fields)
  return _internal_fields(index);
}
inline std::string* SearchRequest::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.SearchRequest.fields)
  return _impl_.fields_.Mutable(index);
}
inline void SearchRequest::set_fields(int index, const std::string& value) {
  _impl_.fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchRequest.fields)
}
inline void SearchRequest::set_fields(int index, std::string&& value) {
  _impl_.fields_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:vearchpb.SearchRequest.fields)
}
inline void SearchRequest::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vearchpb.SearchRequest.fields)
}
inline void SearchRequest::set_fields(int index, const char* value, size_t size) {
  _impl_.fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vearchpb.SearchRequest.fields)
}
inline std::string* SearchRequest::_internal_add_fields() {
  return _impl_.fields_.Add();
}
inline void SearchRequest::add_fields(const std::string& value) {
  _impl_.fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vearchpb.SearchRequest.fields)
}
inline void SearchRequest::add_fields(std::string&& value) {
  _impl_.fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vearchpb.SearchRequest.fields)
}
inline void SearchRequest::add_fields(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vearchpb.SearchRequest.fields)
}
inline void SearchRequest::add_fields(const char* value, size_t size) {
  _impl_.fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vearchpb.SearchRequest.fields)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SearchRequest::fields() const {
  // @@protoc_insertion_point(field_list:vearchpb.SearchRequest.fields)
  return _impl_.fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SearchRequest::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.SearchRequest.fields)
  return &_impl_.fields_;
}

// repeated .vearchpb.RangeFilter range_filters = 7;
inline int SearchRequest::_internal_range_filters_size() const {
  return _impl_.range_filters_.size();
}
inline int SearchRequest::range_filters_size() const {
  return _internal_range_filters_size();
}
inline void SearchRequest::clear_range_filters() {
  _impl_.range_filters_.Clear();
}
inline ::vearchpb::RangeFilter* SearchRequest::mutable_range_filters(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.SearchRequest.range_filters)
  return _impl_.range_filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::RangeFilter >*
SearchRequest::mutable_range_filters() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.SearchRequest.range_filters)
  return &_impl_.range_filters_;
}
inline const ::vearchpb::RangeFilter& SearchRequest::_internal_range_filters(int index) const {
  return _impl_.range_filters_.Get(index);
}
inline const ::vearchpb::RangeFilter& SearchRequest::range_filters(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchRequest.range_filters)
  return _internal_range_filters(index);
}
inline ::vearchpb::RangeFilter* SearchRequest::_internal_add_range_filters() {
  return _impl_.range_filters_.Add();
}
inline ::vearchpb::RangeFilter* SearchRequest::add_range_filters() {
  ::vearchpb::RangeFilter* _add = _internal_add_range_filters();
  // @@protoc_insertion_point(field_add:vearchpb.SearchRequest.range_filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::RangeFilter >&
SearchRequest::range_filters() const {
  // @@protoc_insertion_point(field_list:vearchpb.SearchRequest.range_filters)
  return _impl_.range_filters_;
}

// repeated .vearchpb.TermFilter term_filters = 8;
inline int SearchRequest::_internal_term_filters_size() const {
  return _impl_.term_filters_.size();
}
inline int SearchRequest::term_filters_size() const {
  return _internal_term_filters_size();
}
inline void SearchRequest::clear_term_filters() {
  _impl_.term_filters_.Clear();
}
inline ::vearchpb::TermFilter* SearchRequest::mutable_term_filters(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.SearchRequest.term_filters)
  return _impl_.term_filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::TermFilter >*
SearchRequest::mutable_term_filters() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.SearchRequest.term_filters)
  return &_impl_.term_filters_;
}
inline const ::vearchpb::TermFilter& SearchRequest::_internal_term_filters(int index) const {
  return _impl_.term_filters_.Get(index);
}
inline const ::vearchpb::TermFilter& SearchRequest::term_filters(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchRequest.term_filters)
  return _internal_term_filters(index);
}
inline ::vearchpb::TermFilter* SearchRequest::_internal_add_term_filters() {
  return _impl_.term_filters_.Add();
}
inline ::vearchpb::TermFilter* SearchRequest::add_term_filters() {
  ::vearchpb::TermFilter* _add = _internal_add_term_filters();
  // @@protoc_insertion_point(field_add:vearchpb.SearchRequest.term_filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::TermFilter >&
SearchRequest::term_filters() const {
  // @@protoc_insertion_point(field_list:vearchpb.SearchRequest.term_filters)
  return _impl_.term_filters_;
}

// string index_params = 9;
inline void SearchRequest::clear_index_params() {
  _impl_.index_params_.ClearToEmpty();
}
inline const std::string& SearchRequest::index_params() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchRequest.index_params)
  return _internal_index_params();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchRequest::set_index_params(ArgT0&& arg0, ArgT... args) {
 
 _impl_.index_params_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.SearchRequest.index_params)
}
inline std::string* SearchRequest::mutable_index_params() {
  std::string* _s = _internal_mutable_index_params();
  // @@protoc_insertion_point(field_mutable:vearchpb.SearchRequest.index_params)
  return _s;
}
inline const std::string& SearchRequest::_internal_index_params() const {
  return _impl_.index_params_.Get();
}
inline void SearchRequest::_internal_set_index_params(const std::string& value) {
  
  _impl_.index_params_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchRequest::_internal_mutable_index_params() {
  
  return _impl_.index_params_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchRequest::release_index_params() {
  // @@protoc_insertion_point(field_release:vearchpb.SearchRequest.index_params)
  return _impl_.index_params_.Release();
}
inline void SearchRequest::set_allocated_index_params(std::string* index_params) {
  if (index_params != nullptr) {
    
  } else {
    
  }
  _impl_.index_params_.SetAllocated(index_params, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.index_params_.IsDefault()) {
    _impl_.index_params_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.SearchRequest.index_params)
}

// int32 multi_vector_rank = 10;
inline void SearchRequest::clear_multi_vector_rank() {
  _impl_.multi_vector_rank_ = 0;
}
inline int32_t SearchRequest::_internal_multi_vector_rank() const {
  return _impl_.multi_vector_rank_;
}
inline int32_t SearchRequest::multi_vector_rank() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchRequest.multi_vector_rank)
  return _internal_multi_vector_rank();
}
inline void SearchRequest::_internal_set_multi_vector_rank(int32_t value) {
  
  _impl_.multi_vector_rank_ = value;
}
inline void SearchRequest::set_multi_vector_rank(int32_t value) {
  _internal_set_multi_vector_rank(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchRequest.multi_vector_rank)
}

// bool l2_sqrt = 11;
inline void SearchRequest::clear_l2_sqrt() {
  _impl_.l2_sqrt_ = false;
}
inline bool SearchRequest::_internal_l2_sqrt() const {
  return _impl_.l2_sqrt_;
}
inline bool SearchRequest::l2_sqrt() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchRequest.l2_sqrt)
  return _internal_l2_sqrt();
}
inline void SearchRequest::_internal_set_l2_sqrt(bool value) {
  
  _impl_.l2_sqrt_ = value;
}
inline void SearchRequest::set_l2_sqrt(bool value) {
  _internal_set_l2_sqrt(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchRequest.l2_sqrt)
}

// bool is_vector_value = 12;
inline void SearchRequest::clear_is_vector_value() {
  _impl_.is_vector_value_ = false;
}
inline bool SearchRequest::_internal_is_vector_value() const {
  return _impl_.is_vector_value_;
}
inline bool SearchRequest::is_vector_value() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchRequest.is_vector_value)
  return _internal_is_vector_value();
}
inline void SearchRequest::_internal_set_is_vector_value(bool value) {
  
  _impl_.is_vector_value_ = value;
}
inline void SearchRequest::set_is_vector_value(bool value) {
  _internal_set_is_vector_value(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchRequest.is_vector_value)
}

// map<string, string> sort_field_map = 13;
inline int SearchRequest::_internal_sort_field_map_size() const {
  return _impl_.sort_field_map_.size();
}
inline int SearchRequest::sort_field_map_size() const {
  return _internal_sort_field_map_size();
}
inline void SearchRequest::clear_sort_field_map() {
  _impl_.sort_field_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SearchRequest::_internal_sort_field_map() const {
  return _impl_.sort_field_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SearchRequest::sort_field_map() const {
  // @@protoc_insertion_point(field_map:vearchpb.SearchRequest.sort_field_map)
  return _internal_sort_field_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SearchRequest::_internal_mutable_sort_field_map() {
  return _impl_.sort_field_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SearchRequest::mutable_sort_field_map() {
  // @@protoc_insertion_point(field_mutable_map:vearchpb.SearchRequest.sort_field_map)
  return _internal_mutable_sort_field_map();
}

// repeated .vearchpb.SortField sort_fields = 14;
inline int SearchRequest::_internal_sort_fields_size() const {
  return _impl_.sort_fields_.size();
}
inline int SearchRequest::sort_fields_size() const {
  return _internal_sort_fields_size();
}
inline void SearchRequest::clear_sort_fields() {
  _impl_.sort_fields_.Clear();
}
inline ::vearchpb::SortField* SearchRequest::mutable_sort_fields(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.SearchRequest.sort_fields)
  return _impl_.sort_fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::SortField >*
SearchRequest::mutable_sort_fields() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.SearchRequest.sort_fields)
  return &_impl_.sort_fields_;
}
inline const ::vearchpb::SortField& SearchRequest::_internal_sort_fields(int index) const {
  return _impl_.sort_fields_.Get(index);
}
inline const ::vearchpb::SortField& SearchRequest::sort_fields(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchRequest.sort_fields)
  return _internal_sort_fields(index);
}
inline ::vearchpb::SortField* SearchRequest::_internal_add_sort_fields() {
  return _impl_.sort_fields_.Add();
}
inline ::vearchpb::SortField* SearchRequest::add_sort_fields() {
  ::vearchpb::SortField* _add = _internal_add_sort_fields();
  // @@protoc_insertion_point(field_add:vearchpb.SearchRequest.sort_fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::SortField >&
SearchRequest::sort_fields() const {
  // @@protoc_insertion_point(field_list:vearchpb.SearchRequest.sort_fields)
  return _impl_.sort_fields_;
}

// string ranker = 15;
inline void SearchRequest::clear_ranker() {
  _impl_.ranker_.ClearToEmpty();
}
inline const std::string& SearchRequest::ranker() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchRequest.ranker)
  return _internal_ranker();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchRequest::set_ranker(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ranker_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.SearchRequest.ranker)
}
inline std::string* SearchRequest::mutable_ranker() {
  std::string* _s = _internal_mutable_ranker();
  // @@protoc_insertion_point(field_mutable:vearchpb.SearchRequest.ranker)
  return _s;
}
inline const std::string& SearchRequest::_internal_ranker() const {
  return _impl_.ranker_.Get();
}
inline void SearchRequest::_internal_set_ranker(const std::string& value) {
  
  _impl_.ranker_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchRequest::_internal_mutable_ranker() {
  
  return _impl_.ranker_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchRequest::release_ranker() {
  // @@protoc_insertion_point(field_release:vearchpb.SearchRequest.ranker)
  return _impl_.ranker_.Release();
}
inline void SearchRequest::set_allocated_ranker(std::string* ranker) {
  if (ranker != nullptr) {
    
  } else {
    
  }
  _impl_.ranker_.SetAllocated(ranker, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ranker_.IsDefault()) {
    _impl_.ranker_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.SearchRequest.ranker)
}

// bool trace = 16;
inline void SearchRequest::clear_trace() {
  _impl_.trace_ = false;
}
inline bool SearchRequest::_internal_trace() const {
  return _impl_.trace_;
}
inline bool SearchRequest::trace() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchRequest.trace)
  return _internal_trace();
}
inline void SearchRequest::_internal_set_trace(bool value) {
  
  _impl_.trace_ = value;
}
inline void SearchRequest::set_trace(bool value) {
  _internal_set_trace(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchRequest.trace)
}

// int32 operator = 17;
inline void SearchRequest::clear_operator_() {
  _impl_.operator__ = 0;
}
inline int32_t SearchRequest::_internal_operator_() const {
  return _impl_.operator__;
}
inline int32_t SearchRequest::operator_() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchRequest.operator)
  return _internal_operator_();
}
inline void SearchRequest::_internal_set_operator_(int32_t value) {
  
  _impl_.operator__ = value;
}
inline void SearchRequest::set_operator_(int32_t value) {
  _internal_set_operator_(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchRequest.operator)
}

// -------------------------------------------------------------------

// ResultItem

// double score = 1;
inline void ResultItem::clear_score() {
  _impl_.score_ = 0;
}
inline double ResultItem::_internal_score() const {
  return _impl_.score_;
}
inline double ResultItem::score() const {
  // @@protoc_insertion_point(field_get:vearchpb.ResultItem.score)
  return _internal_score();
}
inline void ResultItem::_internal_set_score(double value) {
  
  _impl_.score_ = value;
}
inline void ResultItem::set_score(double value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:vearchpb.ResultItem.score)
}

// repeated .vearchpb.Field fields = 2;
inline int ResultItem::_internal_fields_size() const {
  return _impl_.fields_.size();
}
inline int ResultItem::fields_size() const {
  return _internal_fields_size();
}
inline ::vearchpb::Field* ResultItem::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.ResultItem.fields)
  return _impl_.fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Field >*
ResultItem::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.ResultItem.fields)
  return &_impl_.fields_;
}
inline const ::vearchpb::Field& ResultItem::_internal_fields(int index) const {
  return _impl_.fields_.Get(index);
}
inline const ::vearchpb::Field& ResultItem::fields(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.ResultItem.fields)
  return _internal_fields(index);
}
inline ::vearchpb::Field* ResultItem::_internal_add_fields() {
  return _impl_.fields_.Add();
}
inline ::vearchpb::Field* ResultItem::add_fields() {
  ::vearchpb::Field* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:vearchpb.ResultItem.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::Field >&
ResultItem::fields() const {
  // @@protoc_insertion_point(field_list:vearchpb.ResultItem.fields)
  return _impl_.fields_;
}

// string p_key = 3;
inline void ResultItem::clear_p_key() {
  _impl_.p_key_.ClearToEmpty();
}
inline const std::string& ResultItem::p_key() const {
  // @@protoc_insertion_point(field_get:vearchpb.ResultItem.p_key)
  return _internal_p_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResultItem::set_p_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.p_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.ResultItem.p_key)
}
inline std::string* ResultItem::mutable_p_key() {
  std::string* _s = _internal_mutable_p_key();
  // @@protoc_insertion_point(field_mutable:vearchpb.ResultItem.p_key)
  return _s;
}
inline const std::string& ResultItem::_internal_p_key() const {
  return _impl_.p_key_.Get();
}
inline void ResultItem::_internal_set_p_key(const std::string& value) {
  
  _impl_.p_key_.Set(value, GetArenaForAllocation());
}
inline std::string* ResultItem::_internal_mutable_p_key() {
  
  return _impl_.p_key_.Mutable(GetArenaForAllocation());
}
inline std::string* ResultItem::release_p_key() {
  // @@protoc_insertion_point(field_release:vearchpb.ResultItem.p_key)
  return _impl_.p_key_.Release();
}
inline void ResultItem::set_allocated_p_key(std::string* p_key) {
  if (p_key != nullptr) {
    
  } else {
    
  }
  _impl_.p_key_.SetAllocated(p_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.p_key_.IsDefault()) {
    _impl_.p_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.ResultItem.p_key)
}

// -------------------------------------------------------------------

// SearchResult

// int32 total_hits = 1;
inline void SearchResult::clear_total_hits() {
  _impl_.total_hits_ = 0;
}
inline int32_t SearchResult::_internal_total_hits() const {
  return _impl_.total_hits_;
}
inline int32_t SearchResult::total_hits() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchResult.total_hits)
  return _internal_total_hits();
}
inline void SearchResult::_internal_set_total_hits(int32_t value) {
  
  _impl_.total_hits_ = value;
}
inline void SearchResult::set_total_hits(int32_t value) {
  _internal_set_total_hits(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchResult.total_hits)
}

// double max_score = 2;
inline void SearchResult::clear_max_score() {
  _impl_.max_score_ = 0;
}
inline double SearchResult::_internal_max_score() const {
  return _impl_.max_score_;
}
inline double SearchResult::max_score() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchResult.max_score)
  return _internal_max_score();
}
inline void SearchResult::_internal_set_max_score(double value) {
  
  _impl_.max_score_ = value;
}
inline void SearchResult::set_max_score(double value) {
  _internal_set_max_score(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchResult.max_score)
}

// int64 max_took = 3;
inline void SearchResult::clear_max_took() {
  _impl_.max_took_ = int64_t{0};
}
inline int64_t SearchResult::_internal_max_took() const {
  return _impl_.max_took_;
}
inline int64_t SearchResult::max_took() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchResult.max_took)
  return _internal_max_took();
}
inline void SearchResult::_internal_set_max_took(int64_t value) {
  
  _impl_.max_took_ = value;
}
inline void SearchResult::set_max_took(int64_t value) {
  _internal_set_max_took(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchResult.max_took)
}

// uint32 max_took_id = 4;
inline void SearchResult::clear_max_took_id() {
  _impl_.max_took_id_ = 0u;
}
inline uint32_t SearchResult::_internal_max_took_id() const {
  return _impl_.max_took_id_;
}
inline uint32_t SearchResult::max_took_id() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchResult.max_took_id)
  return _internal_max_took_id();
}
inline void SearchResult::_internal_set_max_took_id(uint32_t value) {
  
  _impl_.max_took_id_ = value;
}
inline void SearchResult::set_max_took_id(uint32_t value) {
  _internal_set_max_took_id(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchResult.max_took_id)
}

// .vearchpb.SearchStatus status = 5;
inline bool SearchResult::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool SearchResult::has_status() const {
  return _internal_has_status();
}
inline void SearchResult::clear_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
}
inline const ::vearchpb::SearchStatus& SearchResult::_internal_status() const {
  const ::vearchpb::SearchStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::SearchStatus&>(
      ::vearchpb::_SearchStatus_default_instance_);
}
inline const ::vearchpb::SearchStatus& SearchResult::status() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchResult.status)
  return _internal_status();
}
inline void SearchResult::unsafe_arena_set_allocated_status(
    ::vearchpb::SearchStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.SearchResult.status)
}
inline ::vearchpb::SearchStatus* SearchResult::release_status() {
  
  ::vearchpb::SearchStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::SearchStatus* SearchResult::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:vearchpb.SearchResult.status)
  
  ::vearchpb::SearchStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::vearchpb::SearchStatus* SearchResult::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::SearchStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::vearchpb::SearchStatus* SearchResult::mutable_status() {
  ::vearchpb::SearchStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:vearchpb.SearchResult.status)
  return _msg;
}
inline void SearchResult::set_allocated_status(::vearchpb::SearchStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.SearchResult.status)
}

// string msg = 6;
inline void SearchResult::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& SearchResult::msg() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchResult.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchResult::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.SearchResult.msg)
}
inline std::string* SearchResult::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:vearchpb.SearchResult.msg)
  return _s;
}
inline const std::string& SearchResult::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void SearchResult::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchResult::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchResult::release_msg() {
  // @@protoc_insertion_point(field_release:vearchpb.SearchResult.msg)
  return _impl_.msg_.Release();
}
inline void SearchResult::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.SearchResult.msg)
}

// repeated .vearchpb.ResultItem result_items = 7;
inline int SearchResult::_internal_result_items_size() const {
  return _impl_.result_items_.size();
}
inline int SearchResult::result_items_size() const {
  return _internal_result_items_size();
}
inline void SearchResult::clear_result_items() {
  _impl_.result_items_.Clear();
}
inline ::vearchpb::ResultItem* SearchResult::mutable_result_items(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.SearchResult.result_items)
  return _impl_.result_items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::ResultItem >*
SearchResult::mutable_result_items() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.SearchResult.result_items)
  return &_impl_.result_items_;
}
inline const ::vearchpb::ResultItem& SearchResult::_internal_result_items(int index) const {
  return _impl_.result_items_.Get(index);
}
inline const ::vearchpb::ResultItem& SearchResult::result_items(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchResult.result_items)
  return _internal_result_items(index);
}
inline ::vearchpb::ResultItem* SearchResult::_internal_add_result_items() {
  return _impl_.result_items_.Add();
}
inline ::vearchpb::ResultItem* SearchResult::add_result_items() {
  ::vearchpb::ResultItem* _add = _internal_add_result_items();
  // @@protoc_insertion_point(field_add:vearchpb.SearchResult.result_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::ResultItem >&
SearchResult::result_items() const {
  // @@protoc_insertion_point(field_list:vearchpb.SearchResult.result_items)
  return _impl_.result_items_;
}

// uint32 pID = 8;
inline void SearchResult::clear_pid() {
  _impl_.pid_ = 0u;
}
inline uint32_t SearchResult::_internal_pid() const {
  return _impl_.pid_;
}
inline uint32_t SearchResult::pid() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchResult.pID)
  return _internal_pid();
}
inline void SearchResult::_internal_set_pid(uint32_t value) {
  
  _impl_.pid_ = value;
}
inline void SearchResult::set_pid(uint32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchResult.pID)
}

// bool timeout = 9;
inline void SearchResult::clear_timeout() {
  _impl_.timeout_ = false;
}
inline bool SearchResult::_internal_timeout() const {
  return _impl_.timeout_;
}
inline bool SearchResult::timeout() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchResult.timeout)
  return _internal_timeout();
}
inline void SearchResult::_internal_set_timeout(bool value) {
  
  _impl_.timeout_ = value;
}
inline void SearchResult::set_timeout(bool value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchResult.timeout)
}

// int32 topN = 10;
inline void SearchResult::clear_topn() {
  _impl_.topn_ = 0;
}
inline int32_t SearchResult::_internal_topn() const {
  return _impl_.topn_;
}
inline int32_t SearchResult::topn() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchResult.topN)
  return _internal_topn();
}
inline void SearchResult::_internal_set_topn(int32_t value) {
  
  _impl_.topn_ = value;
}
inline void SearchResult::set_topn(int32_t value) {
  _internal_set_topn(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchResult.topN)
}

// -------------------------------------------------------------------

// SearchResponse

// .vearchpb.ResponseHead head = 1;
inline bool SearchResponse::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool SearchResponse::has_head() const {
  return _internal_has_head();
}
inline void SearchResponse::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::vearchpb::ResponseHead& SearchResponse::_internal_head() const {
  const ::vearchpb::ResponseHead* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::vearchpb::ResponseHead&>(
      ::vearchpb::_ResponseHead_default_instance_);
}
inline const ::vearchpb::ResponseHead& SearchResponse::head() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchResponse.head)
  return _internal_head();
}
inline void SearchResponse::unsafe_arena_set_allocated_head(
    ::vearchpb::ResponseHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vearchpb.SearchResponse.head)
}
inline ::vearchpb::ResponseHead* SearchResponse::release_head() {
  
  ::vearchpb::ResponseHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vearchpb::ResponseHead* SearchResponse::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:vearchpb.SearchResponse.head)
  
  ::vearchpb::ResponseHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::vearchpb::ResponseHead* SearchResponse::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::vearchpb::ResponseHead>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::vearchpb::ResponseHead* SearchResponse::mutable_head() {
  ::vearchpb::ResponseHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:vearchpb.SearchResponse.head)
  return _msg;
}
inline void SearchResponse::set_allocated_head(::vearchpb::ResponseHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:vearchpb.SearchResponse.head)
}

// repeated .vearchpb.SearchResult results = 2;
inline int SearchResponse::_internal_results_size() const {
  return _impl_.results_.size();
}
inline int SearchResponse::results_size() const {
  return _internal_results_size();
}
inline void SearchResponse::clear_results() {
  _impl_.results_.Clear();
}
inline ::vearchpb::SearchResult* SearchResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:vearchpb.SearchResponse.results)
  return _impl_.results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::SearchResult >*
SearchResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:vearchpb.SearchResponse.results)
  return &_impl_.results_;
}
inline const ::vearchpb::SearchResult& SearchResponse::_internal_results(int index) const {
  return _impl_.results_.Get(index);
}
inline const ::vearchpb::SearchResult& SearchResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchResponse.results)
  return _internal_results(index);
}
inline ::vearchpb::SearchResult* SearchResponse::_internal_add_results() {
  return _impl_.results_.Add();
}
inline ::vearchpb::SearchResult* SearchResponse::add_results() {
  ::vearchpb::SearchResult* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:vearchpb.SearchResponse.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vearchpb::SearchResult >&
SearchResponse::results() const {
  // @@protoc_insertion_point(field_list:vearchpb.SearchResponse.results)
  return _impl_.results_;
}

// bool timeout = 3;
inline void SearchResponse::clear_timeout() {
  _impl_.timeout_ = false;
}
inline bool SearchResponse::_internal_timeout() const {
  return _impl_.timeout_;
}
inline bool SearchResponse::timeout() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchResponse.timeout)
  return _internal_timeout();
}
inline void SearchResponse::_internal_set_timeout(bool value) {
  
  _impl_.timeout_ = value;
}
inline void SearchResponse::set_timeout(bool value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchResponse.timeout)
}

// bytes FlatBytes = 4;
inline void SearchResponse::clear_flatbytes() {
  _impl_.flatbytes_.ClearToEmpty();
}
inline const std::string& SearchResponse::flatbytes() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchResponse.FlatBytes)
  return _internal_flatbytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchResponse::set_flatbytes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.flatbytes_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.SearchResponse.FlatBytes)
}
inline std::string* SearchResponse::mutable_flatbytes() {
  std::string* _s = _internal_mutable_flatbytes();
  // @@protoc_insertion_point(field_mutable:vearchpb.SearchResponse.FlatBytes)
  return _s;
}
inline const std::string& SearchResponse::_internal_flatbytes() const {
  return _impl_.flatbytes_.Get();
}
inline void SearchResponse::_internal_set_flatbytes(const std::string& value) {
  
  _impl_.flatbytes_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchResponse::_internal_mutable_flatbytes() {
  
  return _impl_.flatbytes_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchResponse::release_flatbytes() {
  // @@protoc_insertion_point(field_release:vearchpb.SearchResponse.FlatBytes)
  return _impl_.flatbytes_.Release();
}
inline void SearchResponse::set_allocated_flatbytes(std::string* flatbytes) {
  if (flatbytes != nullptr) {
    
  } else {
    
  }
  _impl_.flatbytes_.SetAllocated(flatbytes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.flatbytes_.IsDefault()) {
    _impl_.flatbytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.SearchResponse.FlatBytes)
}

// -------------------------------------------------------------------

// SearchStatus

// int32 total = 1;
inline void SearchStatus::clear_total() {
  _impl_.total_ = 0;
}
inline int32_t SearchStatus::_internal_total() const {
  return _impl_.total_;
}
inline int32_t SearchStatus::total() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchStatus.total)
  return _internal_total();
}
inline void SearchStatus::_internal_set_total(int32_t value) {
  
  _impl_.total_ = value;
}
inline void SearchStatus::set_total(int32_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchStatus.total)
}

// int32 failed = 2;
inline void SearchStatus::clear_failed() {
  _impl_.failed_ = 0;
}
inline int32_t SearchStatus::_internal_failed() const {
  return _impl_.failed_;
}
inline int32_t SearchStatus::failed() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchStatus.failed)
  return _internal_failed();
}
inline void SearchStatus::_internal_set_failed(int32_t value) {
  
  _impl_.failed_ = value;
}
inline void SearchStatus::set_failed(int32_t value) {
  _internal_set_failed(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchStatus.failed)
}

// int32 successful = 3;
inline void SearchStatus::clear_successful() {
  _impl_.successful_ = 0;
}
inline int32_t SearchStatus::_internal_successful() const {
  return _impl_.successful_;
}
inline int32_t SearchStatus::successful() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchStatus.successful)
  return _internal_successful();
}
inline void SearchStatus::_internal_set_successful(int32_t value) {
  
  _impl_.successful_ = value;
}
inline void SearchStatus::set_successful(int32_t value) {
  _internal_set_successful(value);
  // @@protoc_insertion_point(field_set:vearchpb.SearchStatus.successful)
}

// string msg = 4;
inline void SearchStatus::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& SearchStatus::msg() const {
  // @@protoc_insertion_point(field_get:vearchpb.SearchStatus.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchStatus::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vearchpb.SearchStatus.msg)
}
inline std::string* SearchStatus::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:vearchpb.SearchStatus.msg)
  return _s;
}
inline const std::string& SearchStatus::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void SearchStatus::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchStatus::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchStatus::release_msg() {
  // @@protoc_insertion_point(field_release:vearchpb.SearchStatus.msg)
  return _impl_.msg_.Release();
}
inline void SearchStatus::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vearchpb.SearchStatus.msg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vearchpb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::vearchpb::IndexParameters_DistanceMetricType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vearchpb::IndexParameters_DistanceMetricType>() {
  return ::vearchpb::IndexParameters_DistanceMetricType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_router_5fgrpc_2eproto
