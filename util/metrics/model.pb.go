// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: model.proto

/*
	Package metrics is a generated protocol buffer package.

	It is generated from these files:
		model.proto

	It has these top-level messages:
		LabelPair
		Metadata
		MetricFamily
		MetricData
		CounterData
		CounterRateData
		GaugeData
		HistogramData
		Bucket
		Percentile
*/
package metrics

import (
	binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// MetricType describes the type of metric.
type MetricType int32

const (
	// UNSET expresses that the metric's type wasn't explicitly set.
	MetricType_UNTYPED     MetricType = 0
	MetricType_COUNTER     MetricType = 1
	MetricType_COUNTERRATE MetricType = 2
	MetricType_GAUGE       MetricType = 3
	MetricType_HISTOGRAM   MetricType = 4
)

var MetricType_name = map[int32]string{
	0: "UNTYPED",
	1: "COUNTER",
	2: "COUNTERRATE",
	3: "GAUGE",
	4: "HISTOGRAM",
}
var MetricType_value = map[string]int32{
	"UNTYPED":     0,
	"COUNTER":     1,
	"COUNTERRATE": 2,
	"GAUGE":       3,
	"HISTOGRAM":   4,
}

func (x MetricType) String() string {
	return proto.EnumName(MetricType_name, int32(x))
}
func (MetricType) EnumDescriptor() ([]byte, []int) { return fileDescriptorModel, []int{0} }

// Unit describes how the metric's units should be displayed.
type Unit int32

const (
	// UNSET expresses that the metric's DisplayUnit wasn't explicitly set.
	Unit_UNSET Unit = 0
	// BYTES expresses that the metric's measurement is in bytes.
	Unit_BYTES Unit = 1
	// CONST expresses that the metric's measurement is a constant value.
	Unit_CONST Unit = 2
	// COUNT expresses that the metric's measurement is a count.
	Unit_COUNT Unit = 3
	// NANOSECONDS expresses that the metric's measurement is in nanoseconds.
	Unit_NANOSECONDS Unit = 4
	// PERCENT expresses that the metric's measurement is a percentage value.
	Unit_PERCENT Unit = 5
	// SECONDS expresses that the metric's measurement is in seconds.
	Unit_SECONDS Unit = 6
)

var Unit_name = map[int32]string{
	0: "UNSET",
	1: "BYTES",
	2: "CONST",
	3: "COUNT",
	4: "NANOSECONDS",
	5: "PERCENT",
	6: "SECONDS",
}
var Unit_value = map[string]int32{
	"UNSET":       0,
	"BYTES":       1,
	"CONST":       2,
	"COUNT":       3,
	"NANOSECONDS": 4,
	"PERCENT":     5,
	"SECONDS":     6,
}

func (x Unit) String() string {
	return proto.EnumName(Unit_name, int32(x))
}
func (Unit) EnumDescriptor() ([]byte, []int) { return fileDescriptorModel, []int{1} }

type LabelPair struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *LabelPair) Reset()                    { *m = LabelPair{} }
func (m *LabelPair) String() string            { return proto.CompactTextString(m) }
func (*LabelPair) ProtoMessage()               {}
func (*LabelPair) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{0} }

// Metadata holds metadata about a metric.
type Metadata struct {
	Name   string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Help   string      `protobuf:"bytes,2,opt,name=help,proto3" json:"help,omitempty"`
	Unit   Unit        `protobuf:"varint,3,opt,name=unit,proto3,enum=Unit" json:"unit,omitempty"`
	Labels []LabelPair `protobuf:"bytes,4,rep,name=labels" json:"labels"`
}

func (m *Metadata) Reset()                    { *m = Metadata{} }
func (m *Metadata) String() string            { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()               {}
func (*Metadata) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{1} }

// MetricFamily contains a list of metrics with the same name (a metric with multiple labels).
type MetricFamily struct {
	Name    string       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Help    string       `protobuf:"bytes,2,opt,name=help,proto3" json:"help,omitempty"`
	Type    MetricType   `protobuf:"varint,3,opt,name=type,proto3,enum=MetricType" json:"type,omitempty"`
	Metrics []MetricData `protobuf:"bytes,4,rep,name=metrics" json:"metrics"`
}

func (m *MetricFamily) Reset()                    { *m = MetricFamily{} }
func (m *MetricFamily) String() string            { return proto.CompactTextString(m) }
func (*MetricFamily) ProtoMessage()               {}
func (*MetricFamily) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{2} }

// MetricData holds exported data of metrics
type MetricData struct {
	Counter     *CounterData     `protobuf:"bytes,1,opt,name=counter" json:"counter,omitempty"`
	CounterRate *CounterRateData `protobuf:"bytes,2,opt,name=counter_rate,json=counterRate" json:"counter_rate,omitempty"`
	Gauge       *GaugeData       `protobuf:"bytes,3,opt,name=gauge" json:"gauge,omitempty"`
	Histogram   *HistogramData   `protobuf:"bytes,4,opt,name=histogram" json:"histogram,omitempty"`
	Labels      []LabelPair      `protobuf:"bytes,5,rep,name=labels" json:"labels"`
	Unit        Unit             `protobuf:"varint,6,opt,name=unit,proto3,enum=Unit" json:"unit,omitempty"`
	TimestampNs int64            `protobuf:"varint,7,opt,name=TimestampNs,proto3" json:"TimestampNs,omitempty"`
}

func (m *MetricData) Reset()                    { *m = MetricData{} }
func (m *MetricData) String() string            { return proto.CompactTextString(m) }
func (*MetricData) ProtoMessage()               {}
func (*MetricData) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{3} }

type CounterData struct {
	Value float64 `protobuf:"fixed64,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *CounterData) Reset()                    { *m = CounterData{} }
func (m *CounterData) String() string            { return proto.CompactTextString(m) }
func (*CounterData) ProtoMessage()               {}
func (*CounterData) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{4} }

type CounterRateData struct {
	TotalValue  float64 `protobuf:"fixed64,1,opt,name=total_value,json=totalValue,proto3" json:"total_value,omitempty"`
	WindowValue float64 `protobuf:"fixed64,2,opt,name=window_value,json=windowValue,proto3" json:"window_value,omitempty"`
	AvgValue    float64 `protobuf:"fixed64,3,opt,name=avg_value,json=avgValue,proto3" json:"avg_value,omitempty"`
}

func (m *CounterRateData) Reset()                    { *m = CounterRateData{} }
func (m *CounterRateData) String() string            { return proto.CompactTextString(m) }
func (*CounterRateData) ProtoMessage()               {}
func (*CounterRateData) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{5} }

type GaugeData struct {
	Value float64 `protobuf:"fixed64,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *GaugeData) Reset()                    { *m = GaugeData{} }
func (m *GaugeData) String() string            { return proto.CompactTextString(m) }
func (*GaugeData) ProtoMessage()               {}
func (*GaugeData) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{6} }

type HistogramData struct {
	SampleCount uint64       `protobuf:"varint,1,opt,name=sample_count,json=sampleCount,proto3" json:"sample_count,omitempty"`
	SampleSum   float64      `protobuf:"fixed64,2,opt,name=sample_sum,json=sampleSum,proto3" json:"sample_sum,omitempty"`
	Buckets     []Bucket     `protobuf:"bytes,3,rep,name=buckets" json:"buckets"`
	Pts         []Percentile `protobuf:"bytes,4,rep,name=pts" json:"pts"`
}

func (m *HistogramData) Reset()                    { *m = HistogramData{} }
func (m *HistogramData) String() string            { return proto.CompactTextString(m) }
func (*HistogramData) ProtoMessage()               {}
func (*HistogramData) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{7} }

type Bucket struct {
	CumulativeCount uint64  `protobuf:"varint,1,opt,name=cumulative_count,json=cumulativeCount,proto3" json:"cumulative_count,omitempty"`
	UpperBound      float64 `protobuf:"fixed64,2,opt,name=upper_bound,json=upperBound,proto3" json:"upper_bound,omitempty"`
}

func (m *Bucket) Reset()                    { *m = Bucket{} }
func (m *Bucket) String() string            { return proto.CompactTextString(m) }
func (*Bucket) ProtoMessage()               {}
func (*Bucket) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{8} }

type Percentile struct {
	Name  string  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Unit  float64 `protobuf:"fixed64,2,opt,name=unit,proto3" json:"unit,omitempty"`
	Value float64 `protobuf:"fixed64,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Percentile) Reset()                    { *m = Percentile{} }
func (m *Percentile) String() string            { return proto.CompactTextString(m) }
func (*Percentile) ProtoMessage()               {}
func (*Percentile) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{9} }

func init() {
	proto.RegisterType((*LabelPair)(nil), "LabelPair")
	proto.RegisterType((*Metadata)(nil), "Metadata")
	proto.RegisterType((*MetricFamily)(nil), "MetricFamily")
	proto.RegisterType((*MetricData)(nil), "MetricData")
	proto.RegisterType((*CounterData)(nil), "CounterData")
	proto.RegisterType((*CounterRateData)(nil), "CounterRateData")
	proto.RegisterType((*GaugeData)(nil), "GaugeData")
	proto.RegisterType((*HistogramData)(nil), "HistogramData")
	proto.RegisterType((*Bucket)(nil), "Bucket")
	proto.RegisterType((*Percentile)(nil), "Percentile")
	proto.RegisterEnum("MetricType", MetricType_name, MetricType_value)
	proto.RegisterEnum("Unit", Unit_name, Unit_value)
}
func (m *LabelPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Help) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Help)))
		i += copy(dAtA[i:], m.Help)
	}
	if m.Unit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Unit))
	}
	if len(m.Labels) > 0 {
		for _, msg := range m.Labels {
			dAtA[i] = 0x22
			i++
			i = encodeVarintModel(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MetricFamily) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricFamily) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Help) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Help)))
		i += copy(dAtA[i:], m.Help)
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Type))
	}
	if len(m.Metrics) > 0 {
		for _, msg := range m.Metrics {
			dAtA[i] = 0x22
			i++
			i = encodeVarintModel(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MetricData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Counter != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Counter.Size()))
		n1, err := m.Counter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.CounterRate != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.CounterRate.Size()))
		n2, err := m.CounterRate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Gauge != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Gauge.Size()))
		n3, err := m.Gauge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Histogram != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Histogram.Size()))
		n4, err := m.Histogram.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Labels) > 0 {
		for _, msg := range m.Labels {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintModel(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Unit != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Unit))
	}
	if m.TimestampNs != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.TimestampNs))
	}
	return i, nil
}

func (m *CounterData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CounterData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i += 8
	}
	return i, nil
}

func (m *CounterRateData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CounterRateData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalValue != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TotalValue))))
		i += 8
	}
	if m.WindowValue != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.WindowValue))))
		i += 8
	}
	if m.AvgValue != 0 {
		dAtA[i] = 0x19
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AvgValue))))
		i += 8
	}
	return i, nil
}

func (m *GaugeData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GaugeData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i += 8
	}
	return i, nil
}

func (m *HistogramData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HistogramData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SampleCount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SampleCount))
	}
	if m.SampleSum != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SampleSum))))
		i += 8
	}
	if len(m.Buckets) > 0 {
		for _, msg := range m.Buckets {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintModel(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Pts) > 0 {
		for _, msg := range m.Pts {
			dAtA[i] = 0x22
			i++
			i = encodeVarintModel(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Bucket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bucket) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CumulativeCount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.CumulativeCount))
	}
	if m.UpperBound != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.UpperBound))))
		i += 8
	}
	return i, nil
}

func (m *Percentile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Percentile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Unit != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Unit))))
		i += 8
	}
	if m.Value != 0 {
		dAtA[i] = 0x19
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i += 8
	}
	return i, nil
}

func encodeVarintModel(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *LabelPair) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *Metadata) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Help)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Unit != 0 {
		n += 1 + sovModel(uint64(m.Unit))
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	return n
}

func (m *MetricFamily) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Help)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovModel(uint64(m.Type))
	}
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	return n
}

func (m *MetricData) Size() (n int) {
	var l int
	_ = l
	if m.Counter != nil {
		l = m.Counter.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.CounterRate != nil {
		l = m.CounterRate.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Gauge != nil {
		l = m.Gauge.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Histogram != nil {
		l = m.Histogram.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if m.Unit != 0 {
		n += 1 + sovModel(uint64(m.Unit))
	}
	if m.TimestampNs != 0 {
		n += 1 + sovModel(uint64(m.TimestampNs))
	}
	return n
}

func (m *CounterData) Size() (n int) {
	var l int
	_ = l
	if m.Value != 0 {
		n += 9
	}
	return n
}

func (m *CounterRateData) Size() (n int) {
	var l int
	_ = l
	if m.TotalValue != 0 {
		n += 9
	}
	if m.WindowValue != 0 {
		n += 9
	}
	if m.AvgValue != 0 {
		n += 9
	}
	return n
}

func (m *GaugeData) Size() (n int) {
	var l int
	_ = l
	if m.Value != 0 {
		n += 9
	}
	return n
}

func (m *HistogramData) Size() (n int) {
	var l int
	_ = l
	if m.SampleCount != 0 {
		n += 1 + sovModel(uint64(m.SampleCount))
	}
	if m.SampleSum != 0 {
		n += 9
	}
	if len(m.Buckets) > 0 {
		for _, e := range m.Buckets {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if len(m.Pts) > 0 {
		for _, e := range m.Pts {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	return n
}

func (m *Bucket) Size() (n int) {
	var l int
	_ = l
	if m.CumulativeCount != 0 {
		n += 1 + sovModel(uint64(m.CumulativeCount))
	}
	if m.UpperBound != 0 {
		n += 9
	}
	return n
}

func (m *Percentile) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Unit != 0 {
		n += 9
	}
	if m.Value != 0 {
		n += 9
	}
	return n
}

func sovModel(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozModel(x uint64) (n int) {
	return sovModel(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LabelPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Help", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Help = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			m.Unit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unit |= (Unit(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, LabelPair{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricFamily) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricFamily: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricFamily: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Help", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Help = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MetricType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, MetricData{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Counter == nil {
				m.Counter = &CounterData{}
			}
			if err := m.Counter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterRate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CounterRate == nil {
				m.CounterRate = &CounterRateData{}
			}
			if err := m.CounterRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gauge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gauge == nil {
				m.Gauge = &GaugeData{}
			}
			if err := m.Gauge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Histogram", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Histogram == nil {
				m.Histogram = &HistogramData{}
			}
			if err := m.Histogram.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, LabelPair{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			m.Unit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unit |= (Unit(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampNs", wireType)
			}
			m.TimestampNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampNs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CounterData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CounterData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CounterData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CounterRateData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CounterRateData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CounterRateData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TotalValue = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.WindowValue = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AvgValue = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GaugeData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GaugeData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GaugeData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HistogramData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HistogramData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HistogramData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleCount", wireType)
			}
			m.SampleCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleSum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SampleSum = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buckets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buckets = append(m.Buckets, Bucket{})
			if err := m.Buckets[len(m.Buckets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pts = append(m.Pts, Percentile{})
			if err := m.Pts[len(m.Pts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bucket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bucket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bucket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativeCount", wireType)
			}
			m.CumulativeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CumulativeCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperBound", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.UpperBound = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Percentile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Percentile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Percentile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Unit = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModel(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModel
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthModel
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowModel
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipModel(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthModel = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModel   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("model.proto", fileDescriptorModel) }

var fileDescriptorModel = []byte{
	// 770 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0x31, 0x8f, 0xe3, 0x44,
	0x18, 0xb5, 0xd7, 0x4e, 0x72, 0xfe, 0x9c, 0xbb, 0xb5, 0x46, 0x14, 0x01, 0x84, 0x93, 0xf3, 0x49,
	0x10, 0x0e, 0xf0, 0x49, 0x39, 0x51, 0xa3, 0x24, 0x6b, 0xb2, 0x20, 0xd6, 0x09, 0x8e, 0x83, 0xb4,
	0x48, 0x28, 0x9a, 0x24, 0x83, 0xd7, 0xc2, 0x8e, 0x2d, 0x67, 0x9c, 0xd5, 0x76, 0x14, 0xfc, 0x00,
	0xfe, 0x01, 0x94, 0xfc, 0x04, 0x4a, 0xca, 0x2d, 0x29, 0xa9, 0xd0, 0x26, 0xfc, 0x01, 0x4a, 0x4a,
	0x34, 0x33, 0x76, 0x9c, 0x05, 0x16, 0x5d, 0xf7, 0x7d, 0xef, 0xbd, 0x99, 0x79, 0x7e, 0xf3, 0x8d,
	0x41, 0x8f, 0x93, 0x15, 0x89, 0xec, 0x34, 0x4b, 0x68, 0xf2, 0xc6, 0x07, 0x41, 0x48, 0xaf, 0xf2,
	0x85, 0xbd, 0x4c, 0xe2, 0x17, 0x41, 0x12, 0x24, 0x2f, 0x38, 0xbc, 0xc8, 0xbf, 0xe6, 0x1d, 0x6f,
	0x78, 0x25, 0xe4, 0xd6, 0x87, 0xa0, 0x7d, 0x86, 0x17, 0x24, 0x9a, 0xe0, 0x30, 0x43, 0x08, 0xd4,
	0x35, 0x8e, 0x49, 0x4b, 0xee, 0xc8, 0x5d, 0xcd, 0xe3, 0x35, 0x7a, 0x0d, 0x6a, 0x5b, 0x1c, 0xe5,
	0xa4, 0x75, 0xc2, 0x41, 0xd1, 0x58, 0xd7, 0xf0, 0xe8, 0x82, 0x50, 0xbc, 0xc2, 0x14, 0xff, 0xe7,
	0x2a, 0x04, 0xea, 0x15, 0x89, 0xd2, 0x62, 0x11, 0xaf, 0xd1, 0xeb, 0xa0, 0xe6, 0xeb, 0x90, 0xb6,
	0x94, 0x8e, 0xdc, 0x7d, 0xd2, 0xab, 0xd9, 0xb3, 0x75, 0x48, 0x3d, 0x0e, 0xa1, 0x2e, 0xd4, 0x23,
	0xe6, 0x62, 0xd3, 0x52, 0x3b, 0x4a, 0x57, 0xef, 0x81, 0x7d, 0x30, 0x35, 0x50, 0x6f, 0x7f, 0x6f,
	0x4b, 0x5e, 0xc1, 0x5b, 0xdf, 0xc9, 0xd0, 0xbc, 0x20, 0x34, 0x0b, 0x97, 0x1f, 0xe3, 0x38, 0x8c,
	0x6e, 0x5e, 0xf9, 0xf4, 0x36, 0xa8, 0xf4, 0x26, 0x25, 0xc5, 0xe9, 0xba, 0x2d, 0x36, 0xf1, 0x6f,
	0x52, 0xe2, 0x71, 0x02, 0xbd, 0x07, 0x8d, 0x98, 0x63, 0xa5, 0x89, 0x52, 0x73, 0x86, 0x29, 0x2e,
	0x5c, 0x94, 0x0a, 0xeb, 0xc7, 0x13, 0x80, 0x8a, 0x45, 0x6f, 0x43, 0x63, 0x99, 0xe4, 0x6b, 0x4a,
	0x32, 0xee, 0x43, 0xef, 0x35, 0xed, 0xa1, 0xe8, 0x19, 0xed, 0x95, 0x24, 0x7a, 0x09, 0xcd, 0xa2,
	0x9c, 0x67, 0x98, 0x8a, 0x4c, 0xf5, 0x9e, 0x51, 0x8a, 0x3d, 0x4c, 0x09, 0x5f, 0xa0, 0x2f, 0x2b,
	0x00, 0x75, 0xa0, 0x16, 0xe0, 0x3c, 0x10, 0xd6, 0x59, 0x36, 0x23, 0xd6, 0x71, 0x9d, 0x20, 0xd0,
	0xfb, 0xa0, 0x5d, 0x85, 0x1b, 0x9a, 0x04, 0x19, 0x8e, 0x5b, 0x2a, 0x57, 0x3d, 0xb1, 0xcf, 0x4b,
	0x84, 0x2b, 0x2b, 0xc1, 0x51, 0xd8, 0xb5, 0xff, 0x0f, 0xfb, 0x70, 0x63, 0xf5, 0x7f, 0xdf, 0x58,
	0x07, 0x74, 0x3f, 0x8c, 0xc9, 0x86, 0xe2, 0x38, 0x75, 0x37, 0xad, 0x46, 0x47, 0xee, 0x2a, 0xde,
	0x31, 0x64, 0x3d, 0x03, 0xfd, 0x28, 0x83, 0x6a, 0x8e, 0x58, 0x40, 0x72, 0x39, 0x47, 0x19, 0x9c,
	0xfe, 0xe3, 0xdb, 0x51, 0x1b, 0x74, 0x9a, 0x50, 0x1c, 0xcd, 0x8f, 0xe5, 0xc0, 0xa1, 0x2f, 0x18,
	0x82, 0x9e, 0x42, 0xf3, 0x3a, 0x5c, 0xaf, 0x92, 0xeb, 0x79, 0x35, 0x98, 0xb2, 0xa7, 0x0b, 0x4c,
	0x48, 0xde, 0x04, 0x0d, 0x6f, 0x83, 0x82, 0x57, 0x38, 0xff, 0x08, 0x6f, 0x03, 0x4e, 0x5a, 0x4f,
	0x41, 0x3b, 0x24, 0xf8, 0x80, 0xad, 0x1f, 0x64, 0x78, 0x7c, 0x2f, 0x3f, 0x76, 0xe8, 0x06, 0xc7,
	0x69, 0x44, 0xe6, 0xfc, 0x6a, 0xb8, 0x5c, 0xf5, 0x74, 0x81, 0xf1, 0x4f, 0x40, 0x6f, 0x01, 0x14,
	0x92, 0x4d, 0x1e, 0x17, 0xae, 0x34, 0x81, 0x4c, 0xf3, 0x18, 0xbd, 0x03, 0x8d, 0x45, 0xbe, 0xfc,
	0x86, 0xd0, 0x4d, 0x4b, 0xe1, 0xb9, 0x37, 0xec, 0x01, 0xef, 0xcb, 0xd9, 0x2a, 0x58, 0xf4, 0x0c,
	0x94, 0x94, 0x56, 0x43, 0x38, 0x21, 0xd9, 0x92, 0xac, 0x69, 0x18, 0x91, 0x42, 0xc8, 0x58, 0xcb,
	0x87, 0xba, 0x58, 0x8d, 0xde, 0x05, 0x63, 0x99, 0xc7, 0x79, 0x84, 0x69, 0xb8, 0xbd, 0xef, 0xee,
	0xb4, 0xc2, 0x85, 0xc3, 0x36, 0xe8, 0x79, 0x9a, 0x92, 0x6c, 0xbe, 0x48, 0xf2, 0xf5, 0xaa, 0xb0,
	0x08, 0x1c, 0x1a, 0x30, 0xc4, 0xfa, 0x14, 0xa0, 0x3a, 0xee, 0xa1, 0xa7, 0xc5, 0x47, 0x42, 0xac,
	0x15, 0xb3, 0x70, 0xc8, 0x50, 0x39, 0xca, 0xf0, 0xf9, 0xe7, 0xe5, 0x0b, 0x61, 0x6f, 0x0c, 0xe9,
	0xd0, 0x98, 0xb9, 0xfe, 0xe5, 0xc4, 0x39, 0x33, 0x24, 0xd6, 0x0c, 0xc7, 0x33, 0xd7, 0x77, 0x3c,
	0x43, 0x46, 0xa7, 0xa0, 0x17, 0x8d, 0xd7, 0xf7, 0x1d, 0xe3, 0x04, 0x69, 0x50, 0x1b, 0xf5, 0x67,
	0x23, 0xc7, 0x50, 0xd0, 0x63, 0xd0, 0xce, 0x3f, 0x99, 0xfa, 0xe3, 0x91, 0xd7, 0xbf, 0x30, 0xd4,
	0xe7, 0x5f, 0x81, 0xca, 0x46, 0x90, 0x29, 0x66, 0xee, 0xd4, 0xf1, 0x0d, 0x89, 0x95, 0x83, 0x4b,
	0xdf, 0x99, 0x1a, 0x32, 0x2b, 0x87, 0x63, 0x77, 0xea, 0x8b, 0x2d, 0xf8, 0x9e, 0x86, 0xc2, 0xb6,
	0x77, 0xfb, 0xee, 0x78, 0xea, 0x0c, 0xc7, 0xee, 0xd9, 0xd4, 0x50, 0xd9, 0xe1, 0x13, 0xc7, 0x1b,
	0x3a, 0xae, 0x6f, 0xd4, 0x58, 0x53, 0x32, 0xf5, 0xc1, 0x47, 0xb7, 0x3b, 0x53, 0xfa, 0x6d, 0x67,
	0xca, 0x77, 0x3b, 0x53, 0xfa, 0x73, 0x67, 0x4a, 0x7f, 0xed, 0x4c, 0xe9, 0xdb, 0xbd, 0x29, 0xfd,
	0xb4, 0x37, 0xa5, 0x9f, 0xf7, 0xa6, 0xf4, 0xcb, 0xde, 0x94, 0x6e, 0xf7, 0xa6, 0xfc, 0xeb, 0xde,
	0x94, 0xef, 0xf6, 0xa6, 0xfc, 0xfd, 0x1f, 0xa6, 0x74, 0x2e, 0x7f, 0x59, 0xfe, 0x15, 0x16, 0x75,
	0xfe, 0x4f, 0x7d, 0xf9, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc1, 0x98, 0x63, 0x2c, 0x91, 0x05,
	0x00, 0x00,
}
